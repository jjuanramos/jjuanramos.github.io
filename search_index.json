[
["index.html", "Herramientas de visualización interactivas para la toma de decisiones en una startup tecnológica. 1 Introducción", " Herramientas de visualización interactivas para la toma de decisiones en una startup tecnológica. Juan Ramos Hernández, Grado en Administración y dirección de Empresas 6/7/2020 1 Introducción Figura 1.1: Mapa de coropletas de los distritos censales de Valencia.Fuente: Elaboración propia. Durante mi etapa como estudiante de Administración y Dirección de Empresas en la Universitat Politècnica de València (UPV) he sentido particular interés por las asignaturas más analíticas y tecnológicas de la carrera. Más específicamente, he intentado aprovechar las oportunidades que nos ha otorgado la universidad de aprender a utilizar herramientas que extienden las capacidades del ser humano y que, una vez habiendo superado la curva inicial de aprendizaje, dotan al usuario de un abanico extenso de recursos para poder validar y contrastar hipótesis e ideas de manera autónoma. Debido a mi interés por la programación y el análisis de datos, he estudiado los lenguajes R y Python al mismo tiempo que realizaba la carrera. Han resultado ser herramientas increíblemente útiles que han tenido un retorno superlativo a la inversión de recursos que he asignado para su aprendizaje. Por ello, me siento afortunado de poder aplicar mis intereses a la hora de desarrollar mi Trabajo de Fin de Grado (TFG). Creo que este proyecto transmitirá lo que he aprendido durante mi tiempo como estudiante, tanto dentro como fuera de la universidad. El objetivo principal de mi TFG es el desarrollo y aplicación de herramientas tecnológicas para la ayuda a la toma de decisiones. Considero que una de las mayores atribuciones de la tecnología ha sido su capacidad para poder resolver problemas que anteriormente carecían de solución. Espero que el mensaje que transmita mi TFG sea ese, que una herramienta es tan útil como el problema que resuelve. El problema que pretendo resolver nace en la empresa en la que trabajo desde octubre de 2019, homyspace. Allí, como analista de datos, me encuentro con no pocos problemas a resolver, los cuales siempre afronto con la mentalidad de desarrollar una solución sencilla, barata y sostenible. Para este proyecto, me voy a centrar en tratar de otorgar una mayor inteligibilidad al ecosistema de proveedores de homyspace, para que el equipo sea capaz de tomar decisiones basadas en datos. La calidad de una decisión no se debería de medir en función de los resultados que obtiene, sino en función de la información que había disponible en el momento que se hizo. Por ende, facilitar el acceso a la mayor cantidad de información posible debería de facilitar la toma de buenas decisiones. "],
["qué-es-homyspace.html", "1.1 ¿Qué es homyspace?", " 1.1 ¿Qué es homyspace? Homyspace es una plataforma del tipo marketplace que se especializa en el alquiler temporal de media estancia para empresas. Cuando una empresa va a trasladar a empleados temporalmente, las opciones por las que opta son, por lo general, poco económicas. Un hotel no está pensado para estancias de treinta días o más. Además, la inversión necesaria para encontrar un alojamiento que encaje con las necesidades de la empresa tiende, por lo general, a ser mayor de la esperada. Homyspace soluciona este problema poniendo en contacto a empresas y arrendatarios, ahorrando tiempo y dinero a la empresa y ofreciendo mayor rentabilidad al arrendador en comparación con el alquiler a largo plazo. Además, aporta mayor seguridad y facilidades en comparación con el alquiler a corto plazo. Homyspace fue fundada en el año 2016 por Ángel Mayoral, Alberto García y Rubén Ballesteros. Una plataforma marketplace facilita un espacio donde la oferta y la demanda para un servicio o producto se puedan conectar para hacer negocios de manera centralizada. Por lo tanto y siguiendo esta definición, homyspace es una plataforma a la cual acuden empresas que tienen la necesidad de desplazar trabajadores, así como dueños de inmuebles que quieren ofrecerlos para servicios de alquiler. Homyspace carece de oferta (inmuebles) propia. Más bien, se encarga de seleccionar y ofrecer a los clientes potenciales inmuebles que encajen con sus requisitos y necesidades de entre una vasta lista de propiedades previamente registradas por sus dueños o gestores. Casi cuatro años después, cuenta con más de cuarenta empleados, decenas de miles de inmuebles registrados y miles de estancias gestionadas en cientos de localizaciones diferentes para clientes de la talla de H&amp;M, Amazon o Bertolín. "],
["definiciones.html", "1.2 Definiciones", " 1.2 Definiciones Antes de adentrarnos en las diferentes partes que componen este proyecto, nos es necesario comprender los conceptos que van a ser mencionados a lo largo del mismo. 1.2.1 Conceptos relacionados con el mundo start-up Marketplace: un marketplace es un término ampliamente utilizado en el mundo de las start-up. Se emplea para referirse a aquellas empresas cuyo modelo de negocio consiste en crear una plataforma donde unificar la oferta y la demanda de un servicio o producto, ejerciendo en ocasiones de intermediario o regulador. Lead: un lead es un usuario que ha entregado sus datos a una empresa, explícita o implícitamente (en este segundo caso, al aceptar la política de privacidad de la empresa), debido a su interés por el servicio o producto que crea la empresa. Embudo o funnel: un funnel o embudo de una empresa define el proceso que se genera de manera interna en la misma desde que el lead deja sus datos, hasta que adquiere el servicio o producto ofrecido por parte de la empresa. Se denomina embudo por la forma que presenta este proceso. Al principio del funnel el número de leads alcanza su máximo, y éste se va reduciendo conforme se aproxima la compra del servicio o producto. Marketing inbound: conjunto de técnicas que se encargan de crear contenido para atraer clientes potenciales, como campañas de marketing o desarrollo de un blog, con el propósito de que sea el cliente el que acuda a la empresa. Marketing outbound: se diferencia del marketing inbound en que, en este caso, es la empresa la que analiza e identifica a los clientes potenciales, y acude a ellos. Está asociado con técnicas de marketing más tradicionales como el marketing de llamadas en frío o telemarketing. 1.2.2 Conceptos relacionados con homyspace Solicitudes: en homyspace, consideramos solicitudes a todas las peticiones de alojamiento por parte de los leads con intención de desplazarse. Se encuentran en la primera etapa del embudo de la demanda de homyspace. Leads cualificados: los leads cualificados son aquellos leads que encajan con la tipología de cliente de homyspace. Empresas que desplazan a sus trabajadores más de 15 días, responsabilizándose del pago de la estancia. Oportunidades: las oportunidades son aquellas solicitudes provenientes de leads cualificados. Las oportunidades son gestionadas por los agentes personales de homyspace Forman parte de la segunda etapa del embudo de homyspace para la demanda. Propuestas: las propuestas son aquellos inmuebles que el agente personal de homyspace considera que encajan mejor con las características y necesidades de la oportunidad en concreto, y que son enviados a la empresa como opciones de alojamiento. Del mismo modo que las oportunidades, éstas también forman parte de la segunda etapa del embudo de homyspace para la demanda. Calendario electrónico o iCal: el calendario electrónico es un programa que permite comprobar de manera automática si el inmueble al que está asociado está o no disponible. Curación de proveedores: la curación de proveedores consiste en la mejora de la base de datos existente de proveedores. Abarca todo lo relacionado con aumentar la calidad de la información relacionada a un inmueble. Por un lado, asegurar que toda la información de los inmuebles es correcta y que las fotos están actualizadas, por el otro, garantizar que el inmueble tiene un calendario electrónico asociado para poder saber instantáneamente si el inmueble está disponible para ser alquilado o no. "],
["flujo-de-trabajo-de-homyspace.html", "1.3 Flujo de trabajo de homyspace", " 1.3 Flujo de trabajo de homyspace A continuación, presentamos una explicación simplificada del flujo de trabajo de homyspace, específicamente desde que un lead (cliente o proveedor) contacta con nosotros hasta que adquiere el servicio que ofrece. El flujo estándar comienza con la entrada del lead, como consecuencia de las acciones de marketing. Podemos diferenciar dos tipos diferentes de leads: Leads de Proveedores: Este lead es el dueño de un inmueble o el gestor de una serie de inmuebles, que está interesado en añadir sus propiedades a la oferta disponible de homyspace. Leads de Empresas: Este lead es un individuo que gestiona el desplazamiento de un grupo de trabajadores o de sí mismo, siempre bajo el amparo de su empresa. 1.3.1 Flujo de Proveedores El flujo de proveedores comienza cuando un potencial proveedor contacta con nuestra empresa. El lead de proveedores va acompañado de información sobre el inmueble, o inmuebles, que ofrece a Homyspace, así como detalles para facilitar el contacto en caso de que su inmueble encaje con una oportunidad. El equipo de proveedores se encarga de analizar la información de cada inmueble, así como de valorar la calidad de las fotos aportadas. Si todo alcanza los requisitos de calidad de homyspace, el inmueble es añadido a la base de datos. Si no es así, se contacta con el proveedor para que mejore las fotos o amplíe la información de los inmuebles ofrecidos. 1.3.2 Flujo de Empresas Del mismo modo, consideramos que el flujo de empresas empieza cuando el empleado de una empresa nos proporciona información para contactar con él. Como hemos indicado en 1.2 Definiciones, esta información se transforma en una solicitud. El equipo de ventas contacta con la empresa que ha realizado la solicitud y, tras obtener la información relevante, la solicitud o bien avanza en el embudo -convirtiéndose en una oportunidad- o es descartada. Las oportunidades resultantes de la etapa anterior son asignadas a los gestores personales de Homyspace. Estos analizan las características de la oportunidad y buscan en la base de datos aquellos inmuebles que encajan mejor con las necesidades del cliente. Cuando encuentran un inmueble que cumple los requisitos crean una propuesta. Normalmente se envía al cliente de 2 a 3 propuestas. La empresa o cliente tiene 24 horas para aceptar las propuestas o rechazarlas. Si se rechazan, el gestor buscará otros inmuebles en la base de datos que encajen mejor con las necesidades del cliente. Si se aceptan, el embudo pasará a la tercera y última etapa, gestionada por el equipo de reservas. Figura 1.2: Flujo de trabajo de homyspace. "],
["objetivos.html", "2 Objetivos", " 2 Objetivos El problema que queremos resolver está centrado en la adquisición y curación de proveedores. ¿Cómo podemos saber en qué zonas necesitamos adquirir inmuebles? Una forma de hacerlo sería comparar la oferta en esa zona con la demanda existente. Pero, ¿qué ocurre cuando sí hay oferta disponible en esa zona pero los inmuebles no están siendo reservados? Quizá el tipo de inmueble en esa zona no encaja con la demanda, o tal vez el problema yace en que los precios no han sido lo suficientemente negociados, o incluso en que hemos estado captando demasiados inmuebles en una zona donde hay oferta de sobra y estamos desperdiciando recursos. Del mismo modo, ¿Cómo negociamos los precios del inmueble con el proveedor adquirido? ¿En qué nos basamos para decirle si tiene un precio “alto” o “bajo”? En referencia a la curación, necesitamos saber de manera ágil qué inmuebles tienen la información asociada actualizada, así como un calendario electrónico asignado. Sin embargo, resulta difícil saber en qué zonas tenemos inmuebles cuya información ha sido recientemente actualizada, y dónde tenemos un mayor número relativo de inmuebles pendientes de ser curados. En un marketplace como Homyspace, el flujo de datos semanal alcanza un tamaño considerable. Cientos de empresas acuden semana a semana para que Homyspace les ofrezca alojamientos que puedan utilizar para sus estancias a medio plazo. Durante el mismo rango de tiempo, son también cientos los inmuebles que se añaden a la base de datos. Los inmuebles son adquiridos de dos formas: a través de técnicas inbound o de técnicas outbound. Antes de la ejecución de estas estrategias de captación, es necesario saber en qué zonas la oferta de Homyspace no está satisfaciendo la demanda. Conforme el volumen de clientes y empresas aumenta, el coste de oportunidad de decidir adquirir en una zona determinada también lo hace. Por lo tanto, tomar la decisión correcta en función de la información disponible en ese momento se vuelve más importante que nunca. "],
["objetivo-general.html", "2.1 Objetivo General", " 2.1 Objetivo General Como objetivo general, este proyecto pretende desarrollar una herramienta de visualización de datos. Un dashboard que implementará gráficos interactivos para ayudar a tomar decisiones inteligentes. Más concretamente, mediante el uso del software libre python se transformarán los datos brutos, actualmente disponibles en formato geoespacial, proporcionando información relacionada con la localización de los inmuebles que forman parte de la base de datos de Homyspace, y se segmentarán por distritos censales definidos por el INE. 1 Al mismo tiempo emplearemos el software libre R y diferentes librerías de su ecosistema para visualizar los datos preparados, de forma que podremos analizar una miríada de métricas relacionadas con cada distrito, lo cual ayudará a comprender mejor el estado de ese distrito y si es necesario que sea un foco de captación o curación de inmuebles. Previo al desarrollo de esta herramienta, el análisis de zonas de captación se realizaba de forma mucho más rudimentaria, a través de hojas de cálculo de Microsoft Excel. Este método, aunque definitivamente útil, es lento, necesita de una descarga y tratamiento de datos previo, y sin lugar a dudas, es inapropiado cuando se está lidiando con datos que requieren de un análisis geoespacial. Y no sólo eso, sino que la dificultad del análisis aumenta de manera exponencial en Microsoft Excel conforme el volumen de datos de homyspace aumenta. Nos es necesario desarrollar una solución a la altura del problema, y para ello R es ideal. Indicadores para secciones censales y cartografía digitalizada, Instituto Nacional de Estadística↩ "],
["objetivos-específicos.html", "2.2 Objetivos Específicos", " 2.2 Objetivos Específicos Con el propósito de alcanzar el objetivo general previamente mencionado, hemos definido una serie de objetivos específicos asociados a acciones concretas. Estos objetivos son: Introducir los gráficos interactivos: qué son y para qué sirven. Defender su uso con respecto a los gráficos tradicionales. Exponer cómo son aplicados en homyspace: qué beneficios aportan y qué inconvenientes presentan. Transmitir la importancia de la creación de una fuente (o fuentes) de datos, así como de su mantenimiento. Presentar el desarrollo de una aplicación de visualización de datos. Mostrar una versión del resultado final. Concluir resumiendo todo lo expuesto, añadiendo posibles vías de mejora de la aplicación. "],
["aplicación-de-gráficos-interactivos-para-la-toma-de-decisiones.html", "3 Aplicación de gráficos interactivos para la toma de decisiones", " 3 Aplicación de gráficos interactivos para la toma de decisiones Figura 3.1: Mapa de calor interactivo que muestra la densidad de inmuebles en Valencia.Fuente: Elaboración propia para exponer las diferencias entre los gráficos estáticos e interactivos. "],
["qué-es-un-gráfico-interactivo.html", "3.1 ¿Qué es un gráfico interactivo?", " 3.1 ¿Qué es un gráfico interactivo? Se ha avanzado mucho en el campo de la visualización de datos. El primer gráfico registrado en la historia data de 1628, creado por Michael Florent van Langren con el propósito de transmitir la magnitud del problema que quería abordar, que consistía en determinar la longitud geográfica. 2 Por entonces, se carecía del conocimiento y de las herramientas que facilitan la creación de gráficos de forma ágil. Aún así, se recurría a ellos por la misma razón por la que los utilizamos a día de hoy: facilitan la comprensión de la información. Con la llegada de los ordenadores, nació la posibilidad de desarrollar gráficos cada vez más complejos, tanto por su diseño y características, como por la cantidad de información que utilizaban como fuente. Gracias al mayor poder computacional, se exploró la viabilidad de que estos gráficos dejaran de ser una “foto” de la información de la que se alimentaban, y se convirtieran en aplicaciones en sí mismas. Así, un gráfico interactivo es un gráfico que permite al usuario interactuar con la información que se utiliza como fuente de datos. Friendly, Michael et al. The First (Known) Statistical Graph: Michael Florent van Langren and the “Secret” of Longitude. (2010).↩ "],
["ventajas-de-los-gráficos-interactivos-frente-a-los-estáticos.html", "3.2 Ventajas de los gráficos interactivos frente a los estáticos", " 3.2 Ventajas de los gráficos interactivos frente a los estáticos A continuación, haremos una comparación de los gráficos interactivos frente a los estáticos. Expondremos las ventajas que ofrece escoger esta tecnología en vez de opciones más tradicionales, así como sus inconvenientes. Para ello, comenzaremos con un ejemplo sencillo, aumentando la complejidad con un segundo ejemplo. La razón de seguir este procedimiento es que las ventajas de emplear gráficos interactivos aumenta, por lo general, con la complejidad de la información expuesta. Hemos creado una fuente de datos que indica, en función de cada país, cuál es la pieza de ropa favorita. Por ejemplo, si la popularidad de los pantalones es del 25% en España, significa que es la prenda favorita del 25% de la población encuestada. A continuación se presentan un gráfico estático tradicional y un gráfico dinámico para describir esta información. ¿Qué gráfico permite un mejor análisis de los datos? Figura 3.2: Gráfico estático que muestra la popularidad de cada prenda por país.Fuente: Elaboración propia para exponer las diferencias entre los gráficos estáticos e interactivos. Figura 3.3: Gráfico dinámico que muestra la popularidad de cada prenda por país.Fuente: Elaboración propia para exponer las diferencias entre los gráficos estáticos e interactivos. Aunque los datos son limitados y, por lo tanto, la información que se puede extraer de los mismos también lo es, hay una diferencia notable entre ambos gráficos a la hora de digerir la información: Podemos saber el porcentaje exacto de popularidad de cada prenda en cada país, simplemente pasando el ratón por encima del gráfico interactivo (Figura 3.3). Así como hacer zoom en los lugares que más nos interesan. De esta forma, aumentan la precisión y la profundidad del análisis. Esto resulta especialmente valioso cuando el volumen de los datos es alto, ya que podemos familiarizarnos con los mismos rápidamente. Podemos filtrar prendas clicando sobre ellas en la leyenda. La productividad del usuario aumenta porque puede realizar el filtrado de manera instantánea, sin necesidad de editar y ejecutar el gráfico cada vez. Esto concede autonomía al usuario, ya que no tiene que depender de un tercero para responder las preguntas que considera convenientes. Del mismo modo, al poder decidir qué información desea visualizar en cada instante, el analista puede tratar datos multidimensionales eficientemente. Concede al usuario un rol activo en la exploración de los datos. Aunque la información sea la misma en el gráfico estático y en el interactivo, el hecho de poder investigar y jugar con los datos ayuda a analizar con más profundidad la información disponible. Un segundo ejemplo: hemos creado una serie de pseudo-inmuebles en Valencia que vamos a trasladar a un mapa. Haremos uso de un mapa de calor para ver en qué zonas de Valencia hay más densidad de inmuebles. Comparemos una visualización estática del mapa frente a una que permita hacer zoom sobre el mapa. Figura 3.4: Mapa de calor estático que muestra la densidad de inmuebles en Valencia.Fuente: Elaboración propia para exponer las diferencias entre los gráficos estáticos e interactivos. Figura 3.5: Mapa de calor interactivo que muestra la densidad de inmuebles en Valencia.Fuente: Elaboración propia para exponer las diferencias entre los gráficos estáticos e interactivos. En este caso, es claramente observable que el gráfico interactivo (Figura 3.5) aporta más valor que el estático (Figura 3.4). Debido a la distancia entre los focos, si quisiéramos hacer uso del mapa estático tendríamos que obtener mapas de las diferentes zonas (Ciutat Vella, Poblat Marítims, etc.) y hacer una comparación a posteriori. Con el mapa interactivo, podemos navegar a través de las diferentes localidades y averiguar de manera sencilla en qué zonas hay una mayor densidad de inmuebles. Y no sólo eso, sino que podemos hacer zoom para obtener una precisión máxima de la localización de cada foco. Las cualidades mencionadas previamente en el punto 1, precisión y profundidad, destacan para el análisis de información geoespacial. Otra ventaja de los gráficos interactivos, es que su implementación puede llegar a ser realmente sencilla. Volviendo al ejemplo de las prendas favoritas por país, el código para crear el gráfico estático (Figura 3.2) es el siguiente: library(ggplot2) # Cargamos la librería ggplot2, la cual utilizaremos para crear el gráfico filepath &lt;- file.path(&quot;data&quot;, &quot;fashionData.csv&quot;) data&lt;- read.csv2(filepath, encoding=&quot;UTF-8&quot;) data &lt;- data %&gt;% rename( Pais = &quot;X.U.FEFF.Pais&quot; ) # Código para crear el gráfico de barras, donde en el eje x tenemos cada país, # en el eje y el nivel de popularidad de cada prenda y donde en cada barra # aparecerá diferenciadas las prendas de ropa por colores fashionPlot &lt;- ggplot(data=data, aes(x=Country, fill = Clothing, y = Popularity)) + geom_bar(stat=&quot;identity&quot;) + labs(title = &quot;Gráfico que muestra prenda favorita por país (A)&quot;, fill = &quot;Prenda&quot;) + scale_x_discrete(name = &quot;País&quot;) + theme_minimal() fashionPlot # aquí mostramos el gráfico Para convertir este gráfico estático en un gráfico interactivo, todo lo que tenemos que hacer es seguir dos pasos: Instalar la librería plotly, la cual nos permite convertir gráficos estáticos en interactivos. Utilizar la función plotly::ggplotly, pasándole como input el gráfico estático previamente creado, fashionPlot. # install.packages(&quot;plotly&quot;) # (Únicamente ejecutaríamos esta línea si no tuviéramos la librería # ya instalada en el ordenador) plotly::ggplotly(fashionPlot) Esta es una forma sencilla de convertir un gráfico estático en un gráfico interactivo, utilizando R. 3.2.1 Inconvenientes de los gráficos interactivos Por desgracia, la implementación de gráficos interactivos también puede suponer inconvenientes y, dependiendo de las necesidades del analista, optar por el uso de gráficos estáticos puede ser acertado en algunos casos. Estos inconvenientes son: Es necesario instalar librerías nuevas. Por lo general, esto no supone un problema si el análisis se realiza en el ordenador del analista. Sin embargo, hay situaciones en las que la aplicación con la que se va a realizar el análisis se almacena en la nube. Esto puede ser un gran inconveniente, ya que la memoria de la localización donde se alberga la aplicación es limitada y, frecuentemente, es inviable aumentar la capacidad de almacenamiento. Siguiendo la lógica del punto anterior, un gráfico interactivo pesa más que uno estático. La implementación de gráficos interactivos puede ser sencilla. Especialmente cuando el gráfico estático original es relativamente simple y ha sido creado utilizado alguna librería de uso generalizado, como puede ser ggplot. Sin embargo, cuando la complejidad del gráfico aumenta o se trata de un gráfico nicho, es muy probable que haya que desarrollar el gráfico utilizando librerías completamente nuevas, incluso obtener tipos de datos diferentes a los utilizados en un gráfico estático. Por ende, es necesario que el analista valore el trade-off que esto supone, y decida si le es rentable aprender a utilizar estas librerías o es preferible decantarse por un gráfico más tradicional. De hecho, esto es lo que ocurre cuando analizamos información geoespacial: las librerías que utilizamos para cada caso son totalmente diferentes y no son combinables (como sí lo son plotly y ggplot2), lo cual exige un desarrollo íntegro tanto del gráfico estático como del interactivo. En resumen, los principales inconvenientes de los gráficos interactivos son sus mayores requerimientos de memoria y la posible inversión de tiempo para aprender a desarrollarlos e implementarlos. "],
["aplicación-de-gráficos-interactivos-para-la-toma-de-decisiones-aspecto-y-componentes.html", "3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes", " 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes Siguiendo una metodología top-down: empezamos utilizando un nivel de abstracción muy alto, donde mostraremos cómo se emplea la herramienta una vez ha sido creada. Veremos el uso actual por parte del equipo de proveedores de la misma, así como su aplicación como herramienta de inversión inmobiliaria. Una vez sepamos para qué se utiliza, reduciremos esta abstracción mostrando cómo ha sido desarrollada, dando así respuesta a una serie de cuestiones: ¿por qué se ha optado por estos gráficos?, ¿por qué mostrar una información determinada y no otra?, etc. Primero, definimos los gráficos interactivos y expondremos sus ventajas con respecto a los gráficos tradicionales, así como sus inconvenientes. A continuación abordaremos el uso del conjunto de gráficos interactivos por parte del equipo de proveedores y veremos en qué situaciones y cómo los utilizan. Por último, expondremos la posible aplicación y comercialización de la herramienta que hemos desarrollado en usos relacionados con la inversión inmobiliaria. A lo largo de esta sección, encontraremos diferentes figuras en las que la información correspondiente a los ejes x o y, así como a la leyenda, han sido cubiertos con un rectángulo negro. Esto lo hacemos para proteger la información de homyspace. Como recordatorio, la razón de existencia de esta aplicación es ayudar a tomar decisiones basadas en datos con respecto a los inmuebles en la base de datos de homyspace, y su interacción con los clientes. La aplicación está compuesta de 6 filtros distintos y de 4 gráficos interactivos diferentes que se ajustan dinámicamente a los filtros indicados. Figura 3.6: Pantalla principal de lo que vemos al abrir la aplicación. El primer filtro con el que nos encontramos, denominado: “Selecciona en función de qué campo colorear el mapa de calor”, afecta exclusivamente al mapa de calor, y es el único de todos los filtros que es directamente visible para el usuario de la aplicación. En función del campo seleccionado, estaremos dando más importancia a la oferta, a la demanda o a la intersección de ambas. Si elegimos “Número de Oportunidades”, el mapa pintará más claro los distritos con menos demanda, y más oscuros aquellos donde nos hacen más solicitudes de alojamiento. Si elegimos “Número de Inmuebles”, el mapa dará mayor o menor importancia a aquellos distritos con más o menos inmuebles respectivamente. Por último, si elegimos “Número de Propuestas Aceptadas”, los distritos más oscuros serán aquellos donde se han aceptado más propuestas. Los más claros aquellos donde menos. Figura 3.7: Pantalla principal de las opciones de coloreado del mapa de calor. Para acceder al resto de filtros, es necesario clicar en el borde izquierdo superior de la pantalla, a la derecha del icono de homyspace que vemos en la figura 3.6. Hecho esto, nos aparecerá una lista vertical de opciones no excluyentes, por lo que podremos combinar diferentes filtros para visualizar la información deseada, como podemos ver en la figura 3.8. Todos los gráficos interactivos exceptuando el mapa se actualizan dinámicamente en función de las opciones escogidas en cada filtro. La razón por la que se ha excluido la actualización del mapa tiene un trasfondo técnico que se explicará en la sección 4.4 Gráficos Interactivos pero, en esencia, el motivo es que si quisiéramos actualizarlo, la velocidad de la aplicación se vería seriamente comprometida. En cualquier caso, estos filtros son: “Filtra por ciudad”: aquí podemos decidir sobre qué ciudades nos muestra información la aplicación. “Filtra por municipio”: aquí podemos ser más concretos y especificar el municipio que queremos visualizar. “Filtra por distrito”: una vez más, podemos aumentar la precisión de los datos y escoger qué distrito censal nos interesa más. “Filtra por número de camas”: en este caso, podemos escoger el número de camas de los inmuebles y propuestas a analizar. “Filtra por número de habitaciones”: por último, podemos elegir el número de habitaciones de los inmuebles y propuestas sobre los que realizar el análisis. Como hemos comentado antes, estos filtros son no excluyentes, por lo que podríamos analizar el estado de los inmuebles de una habitación con dos camas en un distrito de A Coruña, por poner un ejemplo. Figura 3.8: Pantalla principal de los filtros disponibles para decidir qué información mostrar en la aplicación. A continuación, pasaremos a explicar los gráficos empleados en la aplicación. El primer gráfico que vemos al acceder a la aplicación es el mapa por distritos. Figura 3.9: Pantalla principal del mapa de calor al abrir la aplicación. Como podemos ver, el zoom del mapa es a priori muy reducido como para poder diferenciar nada. Aumentamos el zoom para ser capaces de reconocer algunos distritos destacados. Figura 3.10: Pantalla principal del mapa de calor zoomeado en Toledo. Ahora ya somos capaces de separar visualmente ciertos distritos, en zonas como por ejemplo Toledo y Cáceres. Como podemos apreciar en la figura 3.10, hay distritos rojos, amarillos y, si nos fijamos en Madrid, también naranjas. Siguiendo la lógica que hemos comentado antes con respecto al filtro “Selecciona en función de qué campo colorear el mapa de calor” en la figura 3.7, los distritos rojos tienen un mayor número de oportunidades. Después, les siguen los distritos naranjas y, por último, los amarillos. Cabe señalar que no se ha utilizado un número fijo de colores, sino que se ha usado un gradiente de color que varía desde el rojo al amarillo. En los extremos, el color rojo representa a las zonas con mayor número de oportunidades y el amarillo a aquellas con un menor número. Por otro lado, aquellos distritos que vemos de color gris tienen este color porque no tienen oportunidades. Pero si es así: ¿Por qué aparecen distritos sin oportunidades? Si aparecen ciertos distritos sin oportunidades: ¿Por qué no aparecen todos los distritos de España? El motivo es que esos distritos no tienen oportunidades, pero sí inmuebles. Por lo tanto, los distritos en gris son zonas donde tenemos oferta que a día de hoy no ha encajado con las necesidades de nuestros clientes. Habiendo visualizado el mapa, podemos seguir bajando por la aplicación. A continuación, nos encontramos con dos gráficos interactivos. Estos se modifican de dos maneras diferentes: Cuando se clica en un distrito en el mapa, este se actualiza automáticamente para mostrar la información correspondiente al distrito elegido. Cuando se aplican filtros, la información que muestran estos gráficos se filtrará simultáneamente. Por ejemplo: si filtramos por la ciudad de Madrid, la información que utilizarán será exclusivamente la de esta ciudad. Figura 3.11: Pantalla principal mostrando los gráficos que aparecen inmediatamente después del mapa de calor. A la izquierda de la figura 3.11, se muestra un diagrama de caja múltiple (Ampliado en la figura 3.12). A la derecha un gráfico de barras (Ampliado en la figura 3.13). Estos dos gráficos se complementan: el diagrama de caja resume la distribución de precios de los inmuebles de cada distrito en función del número de habitaciones, y el gráfico de barras muestra el número de propuestas aceptadas y rechazadas para inmuebles con diferente número de habitaciones. Figura 3.12: Pantalla principal del diagrama de caja que indica el alquiler de precios en función del número de habitaciones. Figura 3.13: Pantalla principal del gráfico de barras que muestra el número de propuestas aceptadas y rechazadas por número de habitaciones. A continuación, en la figura 3.14 se muestran otras dos visualizaciones interactivas que siguen la misma lógica que los gráficos explicados anteriormente. Figura 3.14: Pantalla principal mostrando la segunda fila de gráficos que aparece tras el mapa de calor. A la izquierda tenemos un gráfico de barras que nos indica el número de inmuebles que hay en el distrito en función del número de habitaciones (ampliado en la figura 3.15). A la derecha, un diagrama de barras que nos indica el porcentaje con respecto al total de inmuebles en el distrito que tienen (o no) calendario electrónico, o iCal (ampliado en la figura 3.16). Figura 3.15: Pantalla principal del gráfico de barras que muestra el número de inmuebles por número de habitaciones. Figura 3.16: Pantalla principal del gráfico de barras que indica el porcentaje de inmuebles con y sin iCal. Finalmente hemos añadido una tabla resumen en la que podemos visualizar toda la información relacionada con cada distrito. Podemos visualizar la estructura de esta tabla en la figura 3.17. Esta tabla contiene filtros propios, muchos más rápidos que los previamente mencionados ya que sólo afectan a la información de la tabla. A diferencia de los filtros previamente expuestos en la figura 3.8, cuya modificación afectaba a todos los componentes de la aplicación (más concretamente los gráficos expuestos en las figuras 3.11 y 3.14), los filtros presentes en la tabla resumen de la figura 3.17 únicamente afectarán a la misma tabla resumen, acelerando mucho la velocidad de carga en comparación con el resto de gráficos, que no se verán afectados con cada alteración de los filtros de la tabla. Esto nos permite abordar el análisis de una manera diferente: en vez de tratar de dar visibilidad al estado de cada distrito, con esta tabla se pretende poder obtener aquellos distritos que cumplan con las condiciones que nos interesen a nosotros. Por ejemplo, podemos filtrar únicamente los distritos cuyo número de propuestas sea mayor de 100 y tengan por lo menos 5 inmuebles reservados. Esta estrategia es útil porque podemos identificar qué distritos están funcionando peor para hacer un análisis posterior de por qué no están funcionando. Del mismo modo, podemos averiguar cuáles sí están funcionando y analizar las posibles razones de su éxito, con el propósito de aplicar una estrategia similar en otros distritos. Figura 3.17: Pantalla principal de la tabla que resume la información por distrito de todas las propuestas. "],
["aplicación-en-el-equipo-de-proveedores.html", "3.4 Aplicación en el equipo de proveedores", " 3.4 Aplicación en el equipo de proveedores Una vez hemos mostrado la aplicación, nos disponemos a desarrollar cómo está siendo utilizada por el equipo de proveedores. En este punto se detalla la metodología que hemos seguido para difundir el uso de la aplicación por parte del equipo de proveedores. Después, visibilizaremos cómo el equipo la utiliza para tareas de captación y negociación, así como de curación. 3.4.1 Métodos para la difusión del uso de la aplicación Tras la creación de la aplicación, es esencial obtener feedback del uso de la misma. Para ello, hemos creado un vídeo en el que hacemos un tour explicando el funcionamiento de la herramienta, para qué casos de uso puede ser de utilidad, cuáles son sus límites y cómo prevemos que será mejorada. Este vídeo se aloja en una plataforma que utilizamos en homyspace para transmitir información entre diferentes miembros del equipo. El vídeo va acompañado de un resumen de las funcionalidades de la aplicación, en caso de que el usuario potencial no quiera invertir tiempo en la visualización del vídeo. Del mismo modo, una vez la aplicación ha sido creada y publicada en un servicio gestionado, realizamos una masterclass con el equipo de proveedores con el propósito de explicar y extender su uso. Asimismo, se realizan reuniones periódicas en las que cada uno de los miembros del equipo expone qué les está gustando, dónde se podría mejorar y a qué no le encuentran utilidad. La difusión de contenido que ayude a emplear la herramienta es tan importante como la creación de la misma, ya que si la aplicación no es utilizada de nada habrá servido desarrollarla. Por ende, si queremos maximizar el ROI (Return On Investment, retorno a la inversión en español) de un proyecto tecnológico, es necesario invertir en la adopción de aquello que es creado. Como recapitulación, la metodología ha consistido en: Formación pasiva, a través de la creación de contenido a la cual puede acudir el usuario (el vídeo tutorial, el resumen). Formación activa, mediante la realización de una masterclass, así como el acuerdo de hacer reuniones periódicas en las que recogemos feedback sobre la aplicación. 3.4.2 Captación A continuación, trataremos los diferentes usos de la aplicación por parte del equipo de proveedores. Un caso de uso para el que se recurre a la aplicación es para ayudar a decidir en qué zonas se van a focalizar los esfuerzos de captación. Es decir, seleccionar en qué focos se deben obtener más inmuebles. Para ello, es necesario responder las siguientes preguntas: ¿Dónde tenemos más producto? ¿Dónde tenemos mayor demanda? ¿En qué lugares está encajando bien la oferta disponible con la demanda? Como hemos indicado antes, estas cuestiones son analizadas a través de la navegación por los distintos filtros disponibles al abrir el mapa, ampliados aquí y en la figura 3.7. Figura 3.18: Pantalla principal de las opciones de coloreado del mapa de calor. En cualquier caso, las preguntas previamente mencionadas son una simplificación del análisis real que realiza el equipo, ya que facilita la asociación de cada pregunta con los filtros creados. Tras haber conversado con un miembro del equipo, exponemos un supuesto proceso en el que se analiza en qué zonas debería de captar homyspace: Primero, el gestor entra en Kibana, la aplicación para visualización de datos de Elasticsearch 3. Esta aplicación permite el análisis de datos en tiempo real, aunque sacrifica la posibilidad de realizar gráficos y visualizaciones más complejas a favor de la actualización instantánea y de la facilidad para crear gráficos. Dentro de Kibana accede al dashboard mostrado en la figura 3.19. Elasticsearch es un motor de búsqueda que facilita el acceso a información almacenada en diferentes índices 4. Un índice es una base de datos que, normalmente, almacena todo el contenido relacionado con un concepto. Por ejemplo, en homyspace podemos tener diferentes índices: uno para inmuebles, otro para solicitudes, otro para propuestas, etc. Y Elasticsearch nos permite acceder a todos a través de Kibana. Kibana es la interfaz de usuario que te permite visualizar los datos a los que Elasticsearch tiene acceso. Por ende, Elasticsearch te permite interactuar con toda la información que se va registrando en las bases de datos de homyspace a tiempo real a través de Kibana. Figura 3.19: Pantalla principal del dashboard de Kibana utilizado para hacer un análisis superficial del estado de la demanda. En este dashboard podemos ver en qué localizaciones estamos recibiendo más demanda, así como dónde están convirtiendo más. Del mismo modo, el gestor puede aplicar filtros de localización, por el número de personas que se van a desplazar, etc. Así, se puede hacer una idea inmediata de en qué zonas debería de centrar el análisis. Los rectángulos negros están ocultando la leyenda que nos indica qué ciudad representa cada color. Esto lo hacemos debido a la confidencialidad de la información de homyspace. Arriba de los gráficos observamos rectángulos azules y rojos, estos rectángulos son filtros que permiten al usuario seleccionar rápidamente el tipo de información que quiere visualizar. Cuando el rectángulo es de color azul es porque está aplicado de forma estándar. Si es azul con lineas blancas, como es el caso en este ejemplo, es porque está desactivado. Por último, si está en color rojo es porque está aplicado de forma inversa, es decir, queremos que nos muestre todo aquello diferente a lo que el filtro indica. ¿Por qué no realizar todo el análisis en Kibana? A pesar de las ventajas previamente mencionadas de Kibana: su capacidad para estar actualizado constantemente y su facilidad para crear gráficos por lo general interactivos-, no ofrece la posibilidad de adaptación de los gráficos a la información a analizar (es decir, no podemos desarrollar un mapa como el creado en Shiny), su catálogo de gráficos es muy limitado, y la inserción de información que no se encuentre ya en la base de datos de la que se alimenta (un índice de Elasticsearch) es muy compleja, a menudo imposible. Después, habiendo decidido en qué ciudades quiere profundizar, acude a la aplicación de Shiny. Aquí, podrá ir más allá del análisis por ciudad y podrá diferenciar el estado de cada distrito de esa ciudad. Por ejemplo, digamos que escoge Valencia. En ese caso, hará zoom en la ciudad de Valencia y podrá visualizar los diferentes distritos en función del filtro escogido para colorearlos. En el ejemplo, la información mostrada ha sido falsificada para no revelar información de homyspace. No obstante, los campos que aparecen en el pop-up tras clicar en cada distrito son los mismos campos que se utilizan en la aplicación real. Figura 3.20: Definiciones de los campos mostrados en el pop-up del mapa de calor. Figura 3.21: Mapa de coropletas de los distritos censales de Valencia.Fuente: Elaboración propia para exponer el uso del mapa por parte del equipo de proveedores. Con esta información, el gestor puede analizar el estado de salud de cada distrito y plantearse preguntas que ahora sí puede responder, tales como: ¿Qué distrito de la ciudad tiene mayor ratio de conversión? Si el distrito con más demanda tiene baja conversión, ¿es por falta de producto? ¿por precios? Si es por precios, ¿cuál de los distritos más cercanos tiene mejores precios? ¿Tenemos suficiente oferta en ese distrito? Podemos captar ahí y ofrecer el producto a clientes potenciales que tengan coche o con presupuesto más ajustado Este distrito tiene muchos inmuebles, pero muy pocos de ellos han sido propuestos. ¿Por qué? ¿No encajan con lo que necesitan los clientes? Del mismo modo, este distrito tiene pocos inmuebles pero se han reservado todos. ¿Necesitamos captar más? ¿Qué características tienen esos inmuebles? ¿Podemos replicar esa tipología de inmueble en otras zonas? En conclusión, aunque la aplicación no es la solución única y definitiva para la toma de decisiones con respecto a la captación de nuevos inmuebles, sí permite hacerse preguntas más concretas, así como profundizar más en cada zona y por ende, concretar acciones más precisas. Todo esto sumado a la facilidad de uso de la aplicación, conseguida a través de, por un lado, un proceso iterativo que ha permitido perfeccionar la aplicación hasta alcanzar el punto en el que se encuentra ahora y, por el otro, a la flexibilidad y capacidad de Shiny, que permiten adaptar la aplicación rápidamente a los problemas que surgen de forma dinámica en el departamento, evitando la obsolescencia de la herramienta. 3.4.3 Negociación Por otro lado, para la negociación con potenciales nuevos proveedores, el equipo se informa de la localización del inmueble, inserta la localización en el mapa y analiza si nos interesa añadir ese inmueble, y a qué precio. Digamos, para mantener el ejemplo consistente con el anterior, que la calle de este inmueble es “Carrer d’Àngel Guimerà”. Entonces, el gestor buscará esta ubicación en el mapa mostrado en la figura 3.21 (debajo de los iconos para zoomear hay un cuadrado que, al clicarlo, muestra un buscador). Si el buscador encuentra la ubicación, indicará en qué distrito se encuentra. En ese caso, el gestor clicará en el distrito y todos los gráficos bajo el mapa se actualizarán para mostrar la información correspondiente a ese distrito. Tras haber hecho esto, todos los gráficos interactivos expuestos en las figuras 3.11 y 3.14 se adaptarán para mostrar la información correspondiente al distrito. De este modo el gestor podrá: Analizar si nos interesa ese inmueble: ¿tenemos suficientes inmuebles con esas características? ¿Tiene esa tipología de inmueble un historial de encajar con las necesidades del cliente? Si es así, el gestor podrá negociar con el proveedor basándose en datos. Observando el diagrama de caja, el gestor será capaz de reconocer de forma inmediata si el precio que el proveedor sugiere es demasiado caro y dar argumentos sólidos para convencer de una reducción de precios. Argumento estándar: “El precio que me indicas está por encima del precio del X% de inmuebles con las mismas características que tenemos en esta zona”. Figura 3.22: Gráfico interactivo que muestra la distribución del alquiler de precios en función del número de habitaciones.Fuente: Elaboración propia para exponer el uso del diagrama de caja por parte del equipo de proveedores. Figura 3.23: Gráfico interactivo que muestra el número de inmuebles por número de habitaciones en el distrito.Fuente: Elaboración propia para exponer el uso del gráfico de barras por parte del equipo de proveedores. Figura 3.24: Gráfico interactivo que muestra el número de propuestas aceptadas y rechazadas en función del número de habitaciones.Fuente: Elaboración propia para exponer el uso del gráfico de barras por parte del equipo de proveedores. 3.4.4 Curación Otra tarea para la que el equipo de proveedores recurre a la herramienta es para tareas de curación. Como hemos comentado en la sección 1.2.2 Conceptos relacionados con homyspace, llamamos curación de proveedores a la mejora de la base de datos existente de proveedores.. Frecuentemente, esto implica maximizar el número de enlaces para acceder a los calendarios electrónicos asociados a los inmuebles. Esto facilita la creación automática de propuestas, ya que no hace falta comprobar la disponibilidad de un inmueble manualmente. Nos lo indica iCal. Por lo tanto, a la hora de realizar curación de la base de datos, el equipo de proveedores sigue una estrategia similar a la empleada en captación: Primero, el gestor entra en Kibana y analiza qué zonas tienen más demanda con el dashboard previamente mostrado en la figura 3.19. Después, entra en la aplicación y analiza cada uno de los distritos de esa zona, dándole particular importancia al gráfico mostrado en la figura 3.16. Tras haber visualizado el porcentaje de inmuebles con iCal, así como el número de inmuebles y el ratio de conversión de ese distrito, el gestor establece un porcentaje objetivo de inmuebles con iCal a alcanzar. Hecho esto, el gestor decide qué distritos priorizar y cuántos de ellos tratar. Figura 3.25: Gráfico interactivo que muestra el porcentaje de inmuebles con y sin iCal en el distrito.Fuente: Elaboración propia para exponer el uso del gráfico de barras por parte del equipo de proveedores. Kibana↩ Elasticsearch↩ "],
["aplicación-como-herramienta-de-inversión.html", "3.5 Aplicación como herramienta de inversión", " 3.5 Aplicación como herramienta de inversión Por último, la aplicación se ha utilizado como asistente para la toma de decisiones en el sector de inversión inmobiliaria. Para ello, el inversor comparte las direcciones y características de los inmuebles que está valorando para realizar la inversión. Tras esto, enviamos las direcciones como input a un algoritmo que devuelve como output la geolocalización de estos edificios, así como a qué distrito pertenecen. Después, añadimos estos datos a la información inicial, constituyendo el fichero que vamos a pasar al mapa de calor. Entonces, añadimos la información del fichero como una capa adicional al mapa de calor inicial, indicando con marcadores la localización de estos edificios. También otorgamos interactividad a estos marcadores, pues al clicarlos obtendremos información con respecto a su número de inmuebles en función del número de habitaciones, al mismo tiempo que el resto de gráficos interactivos se adaptarán para mostrarnos la información relativa al distrito que contiene el marcador en cuestión. Aunque el ejemplo mostrado a continuación sólo contiene 4 ejemplos de edificios, en los casos de uso en los que se ha sido empleado las opciones superaban los 200 edificios por toda España, por lo que poder reflejar todas estas ubicaciones en un mapa interactivo facilita la toma de decisiones, agilizando la comparación de opciones así como amplificando la información relacionada con cada una de ellas. Figura 3.26: Mapa de coropletas de los distritos censales de Valencia con una capa añadida con las localizaciones de los edificios disponibles en los que invertir.Fuente: Elaboración propia para exponer el uso del mapa como herramienta de inversión "],
["desarrollo-de-la-aplicación.html", "4 Desarrollo de la aplicación", " 4 Desarrollo de la aplicación En esta sección, abordaremos la parte más técnica de este proyecto: Desde la creación de ETL pipelines, cuyo significado explicaremos en la sección 4.1.2 ETL Pipeline: Definición, hasta la selección y desarrollo de los diferentes gráficos que componen la aplicación, así como la configuración de la interacción dinámica entre los diferentes componentes de la misma. Para empezar, documentaremos la creación de las fuentes de datos: De dónde obtenemos la información y el proceso que seguimos para unificarla en una sola plataforma y facilitar su uso. Nos centraremos en transmitir la importancia de la creación de una fuente (o fuentes) de datos, así como de su mantenimiento. Después, presentaremos el desarrollo de la aplicación de gráficos interactivos, tanto de cada uno de sus componentes como de la interacción entre los mismos, donde hacemos uso de la funcionalidad de reactividad de Shiny, concepto que definiremos en la sección 4.5.5 Desarrollo de los gráficos y de la reactividad. También justificaremos por qué hemos decidido emplear cada gráfico en particular y no otro. "],
["fuente-de-datos.html", "4.1 Fuente de datos", " 4.1 Fuente de datos 4.1.1 Introducción Figura 4.1: Imagen que refleja la importancia de la preparación de los datos en un proyecto que gira en torno a los mismos. Aunque no sea una tarea visible, la preparación de la información para que pueda ser explotada es la base de cualquier proyecto relacionado con la visualización de datos. Es, por lo general, la parte del proyecto más laboriosa, extensa y, a menudo, técnica. Antes de explicar qué motivos nos llevan a decir esto, nos es necesario definir terminología básica que se utiliza en el campo de la adaptación de datos para su uso: Limpieza de datos: data cleaning en inglés, consiste en detectar y tratar información incompleta, incorrecta, imprecisa o irrelevante procedente de un conjunto de datos, ya sea modificándola, reemplazándola o eliminándola del mismo conjunto. Forma parte del proceso de transformación de los datos, que explicaremos en la sección 4.1.2 ETL Pipeline: Definición. Datos crudos: raw data en inglés, nos referimos al conjunto de datos antes de pasar por el proceso de limpieza. Datos limpios: clean data en inglés, es el conjunto de datos tras haber pasado por el proceso de limpieza. Aclarados estos términos, ya podemos adentrarnos en la explicación de por qué la preparación de la información puede ser tan compleja. Para empezar, los datos crudos rara vez están adaptados para facilitar su explotación. Esto se puede deber a diferentes razones: Los datos no han sido almacenados siguiendo una estructura que facilite su almacenamiento. El proceso a seguir para optimizar el almacenamiento de la información no tiene por qué ser el mismo que el empleado para optimizar su explotación. Hay errores en el proceso de almacenamiento: Por ejemplo, los casos vacíos se gestionan de manera diferente en cada columna o en función del tipo de información almacenada. Un ejemplo claro de esto es rellenar los casos vacíos de una columna compuesta por elementos del tipo string con \"\" y los casos vacíos de una columna compuesta por elementos del tipo float con NA. El conjunto de datos no va acompañado de un documento que explique el significado de cada columna. Cada conjunto de datos está almacenado en una plataforma diferente. Por otro lado, durante el proceso de limpieza de datos nos encontramos con problemas nuevos frecuentemente, por lo que la automatización de la limpieza de cada conjunto de datos que obtengamos es inviable. Para expresarnos de manera clara y concisa, reciclaremos la frase de Tolstói: “Todas las familias felices se parecen unas a otras, pero cada familia infeliz lo es a su manera”. Para el proceso de adaptación de los datos crudos, diríamos algo así: “Los conjuntos de datos adaptados para su explotación se parecen unos a otros, pero cada conjunto de datos crudos es diferente a su manera”. Cada vez que tratemos un conjunto de datos por primera vez, tendremos que ser conscientes de esto. Todavía no existe ningún software capaz de recibir como input cualquier conjunto de datos y devolver como output los datos adaptados para su explotación. 4.1.2 ETL Pipeline: Definición Las siglas representan Extract (extraer), Transform (transformar) y Load (cargar). Del mismo modo, una pipeline en ingeniería informática se refiere a un conjunto de elementos que se ejecutan secuencialmente, donde el output de cada elemento es el input del siguiente. Por ende, Una ETL Pipeline es un conjunto de procesos que engloba extraer datos de diferentes fuentes de datos, transformarlos para permitir su uso y cargarlos en una base de datos o un sistema de alojamiento de archivos. Para este proyecto, la ETL Pipeline que desarrollaremos tendrá como fin albergar en el sistema de almacenamiento a elegir, en este caso Dropbox debido a su facilidad de conexión a través de su API, un conjunto de datos adaptados para poder analizar el estado de cada distrito desde el punto de vista de la oferta (inmuebles), la demanda (oportunidades) y su intersección (propuestas). 4.1.3 Orígenes de datos Utilizamos diferentes fuentes de datos para componer los distintos conjuntos de datos de los que hace uso la aplicación. Obtenemos los datos crudos de dos fuentes diferentes: Del Instituto Nacional de Estadística obtenemos el archivo del tipo Shapefile que vamos a utilizar para definir los distritos censales 5. Para ello, tendremos que realizar una transformación de datos. Este archivo crea multipolígonos (conjunto de puntos geográficos, cada uno con sus propias coordenadas, que al unirse crean un espacio cerrado) que delimitan cada sección censal en el mapa de España. No obstante, las secciones censales son demasiado pequeñas como para agrupar un conjunto de inmuebles lo suficientemente grande como para que las conclusiones extraídas sean significativas. Por ello, las disolvemos en los distritos censales que utilizaremos. Cada distrito censal está compuesto por un conjunto de secciones censales, y disolverlas implica agrupar todos los multipolígonos de cada distrito censal y convertirlo en uno sólo. Figura 4.2: Imagen que refleja la disolución de las secciones censales del municipio de Valencia a distritos censales. Fuente: INE. De hecho, esta es la primera ETL Pipeline de la que hacemos uso. ¿Por qué? Porque estamos extrayendo los datos del INE (extract), transformándolos de su unidad original como secciones censales a distritos censales (transform) y, por último, subiendo la información ya transformada a Dropbox para poder cargarla y utilizarla cuando nos sea conveniente (load). Por ende, podemos decir que para construir nuestra ETL Pipeline principal es necesario crear una previa, menos compleja. Por otro lado, los datos de homyspace los obtenemos de Elasticsearch: recurrimos a diferentes índices para obtener la información. Como hemos indicado en la sección 3.4.2 Captación, un índice es una base de datos que, por lo general, almacena todo el contenido relacionado con un concepto. Ya que estamos interesados en las oportunidades, propuestas e inmuebles de homyspace, necesitamos conectarnos a Elasticsearch para acceder a sus índices correspondientes. Para extraer estos datos, volvemos a recurrir a python ¿No es la primera vez que nombras este programa?. Creamos una función a la que llamamos getData, a la cual pasaremos como input el índice en cuestión, las columnas que deseamos extraer de ese índice, y filtros opcionales. Habiendo utilizado la primera pieza de código para preparar la información geoespacial del INE para su uso, y teniendo la capacidad de extraer datos de los diferentes índices de Elasticsearch a través de la segunda pieza de código, ya estamos preparados para poder diseñar y desarrollar la pipeline que vamos a utilizar para adaptar los datos para el uso por parte de la aplicación. Cartografía digitalizada: Contorno de las secciones censales a 1 de noviembre de 2011 en formato SHP (comprimido ZIP)↩ "],
["diseño-de-la-pipeline.html", "4.2 Diseño de la Pipeline", " 4.2 Diseño de la Pipeline La ETL Pipeline se diferencia en las etapas de extracción, de transformación y de carga de los datos. Para la etapa de extracción, haremos uso de lo mencionado en el punto 4.1.3 Orígenes de los datos: por un lado, descargaremos el fichero de distritos censales que tenemos alojado en Dropbox y, por el otro, a través de la función getData, extraeremos de los diferentes índices de Elasticsearch la información correspondiente a las oportunidades, las propuestas y los inmuebles. Hecho esto, también crearemos funciones para la segunda etapa, transformación. Primero desarrollaremos aquella función que, dados como inputs unas coordenadas y los distritos censales del INE, devuelva el distrito censal al que pertenecen estas coordenadas. Esta función la utilizaremos tanto con los inmuebles como con las oportunidades. Después, y ya con los inmuebles asociados a sus respectivos distritos, podremos obtener los distritos de las propuestas identificando los inmuebles de cada propuesta. De este modo, ya habremos localizado las oportunidades, inmuebles y propuestas de cada distrito. Por último agruparemos toda esta información por distrito, para tener en un único fichero la información relativa a la demanda, oferta y el encaje de estas de cada distrito. En lo que a la fase de carga se refiere, nos conectamos con Dropbox, donde guardaremos cuatro ficheros diferentes. Los dos primeros serán del tipo Shapefile, e indicarán la geolocalización de los inmuebles y de las oportunidades. La razón por la que creamos estos documentos y los almacenamos es porque el volumen de inmuebles y oportunidades es lo suficientemente grande como para ralentizar la ejecución de la ETL Pipeline si lo hiciéramos desde cero cada vez. Almacenando estos datos, podemos ejecutar la función de la localización de las coordenadas en los distritos únicamente en los inmuebles y oportunidades que no han sido previamente localizados. Asimismo, convertimos en CSV las propuestas con los distritos indicados. Este fichero lo utilizaremos para la mayoría de gráficos interactivos que no son el mapa. Todo lo que necesitamos para convertir el documento a CSV es eliminar la columna que indica el multipolígono del distrito en el que se encuentra cada propuesta. Además, exportaremos a CSV el documento en el que hemos agrupado y resumido la información por distritos, siguiendo el mismo proceso de eliminación de la columna con el multipolígono. Utilizaremos este fichero para la tabla resumen que se encuentra al final de la aplicación. Figura 4.3: Estructura de la ETL Pipeline desarrollada para la aplicación. "],
["desarrollo-de-la-pipeline.html", "4.3 Desarrollo de la Pipeline", " 4.3 Desarrollo de la Pipeline Para empezar, cargaremos las librerías necesarias para acceder a las diferentes fuentes de datos. Utilizaremos elasticsearch y elasticsearch_dsl para conectarnos con Elasticsearch. Como en homyspace utilizamos la versión de Amazon Web Services (AWS), también cargaremos requests_aws4auth. Esta librería nos permite autentificarnos con AWS utilizando las credenciales adecuadas. A través de la librería de dropbox, seremos capaces de acceder a Dropbox, tanto para descargar documentos como para subirlos. Con requests y zipfile extraeremos los archivos ZIP en los que tenemos comprimidos los documentos Shapefile de los distritos y de los inmuebles, cuyos distritos ya hemos identificado previamente. Utilizaremos pandas y numpy para gestionar los datos. Con estas dos librerías realizaremos toda la limpieza de datos que sea necesaria. Por último, geopandas y shapely nos permitirán tratar la información geoespacial, dándonos la posibilidad de crear y alterar documentos Shapefile. Siguiendo los pasos necesarios para poder realizar la etapa de extracción, nos conectamos con Elasticsearch. Habiendo instalado las librerías necesarias, así como habiendo desarrollado las funciones y la conexión a Dropbox y Elasticsearch respectivamente, nos disponemos a diferenciar las funciones creadas y utilizadas en función de la etapa de la ETL Pipeline a la que pertenecen. Después, en la sección 4.3.4 Arquitectura final y gestión de la actualización indicaremos cómo unimos estas funciones para crear la ETL Pipeline que deseamos. 4.3.1 Extracción (extract) Comenzaremos por la etapa de extracción. Como hemos mencionado en la sección 4.1.2 ETL Pipeline: Definición, el propósito de esta etapa es habilitar el acceso a la información para ser capaces de hacer uso de ella más adelante. Dividiremos las funciones que hacemos en dos: Por un lado tenemos getPropertiesData, getOpportunitiesData y getProposalsData. Estas tres funciones nos conectan con Elasticsearch, y nos permiten extraer los datos de los índices relacionados con inmuebles, oportunidades y propuestas, respectivamente. En la figura 4.3, representaría la parte relacionada con Elasticsearch de la etapa de extracción. Por el otro, hemos creado las funciones getDistrictsFromDBX, getPropertiesFromDBX y getOpportunitiesFromDBX. Con estas funciones podemos acceder a los distritos censales y a los inmuebles y oportunidades cuyos distritos ya han sido asignados en previos lanzamientos de la ETL Pipeline. Con este conjunto de funciones ya hemos satisfecho todos los requerimientos para acceder a la información que nos aporta valor. No obstante, todavía no ha sido tratada para que nos aporte ese valor. Para ello, necesitamos del proceso de transformación, en el cual ahondaremos a continuación. 4.3.2 Transformación (transform) El proceso de transformación de los datos consiste en, dado un conjunto de información recibida como input, realizar una serie de alteraciones de ese input (ya sean adiciones, substracciones o modificaciones) para obtener un output que nos sea útil para un fin específico. Al igual que en la etapa de extracción, podemos dividir las funciones para la transformación en dos: Primero, tenemos las funciones que utilizaremos para, una vez recibidos los datos de los inmuebles y oportunidades, asignar a cada uno de ellos el distrito en el que se encuentran. En la figura 4.3, estas funciones equivalen a la 1 (assignDistrictsToProperties) y 2 (assignDistrictsToOpportunities) de la etapa de transformación. El paso 3 (assignPropertiesToProposals) también pertenece a este subconjunto, aunque se diferencia en el hecho de que, como ya hemos asignado los inmuebles a sus distritos, todo lo que tendremos que hacer para localizar las propuestas será relacionarlas a sus inmuebles asociados, cuyos distritos ya han sido aclarados. La última de las funciones que necesitamos para completar el proceso de transformación es la que equivale al paso 4 en la figura 4.3. Con esta función agruparemos por distrito todo la información relativa a las oportunidades, los inmuebles y las propuestas. De esta transformación obtendremos los datos que necesitamos para crear el mapa en la aplicación de gráficos interactivos. No obstante, para ello necesitamos almacenar esta información y la que hemos transformado en una plataforma de almacenamiento de datos. Nosotros hemos elegido Dropbox debido a la facilidad de conexión con su API y a que, además, podemos guardar hasta 2GB gratuitamente, lo cual es más que de sobra para nuestro caso de uso. En la sección 7.1 Desarrollo de la aplicación mostramos las funciones que hemos utilizado para almacenar la información correspondiente en Dropbox. 4.3.3 Carga (load) En la última etapa de la ETL Pipeline nos centramos en almacenar toda la información que hemos obtenido como output de la etapa de transformación. Siguiendo la misma dinámica de las dos etapas anteriores, en la etapa de carga podemos diferenciar en dos las funciones creadas: Por un lado, creamos las funciones backup, checkFileDetails y uploadDropbox. A través de las mismas subiremos los ficheros correspondientes a la platafroma de Dropbox. Por el otro, tenemos las funciones savePropertiesToDBX, saveOpportunitiesToDBX, saveHeatmapToDBX y saveProposalsToDBX. Con estas funciones estamos transformando los datos en ficheros CSV o SHP y, para el último, comprimiéndolo en un ZIP antes de subirlos a Dropbox con ayuda de la función uploadDropbox. Habiendo creado todas estas funciones, ya somos capaces de hacer uso de nuestra propia ETL Pipeline. En la próxima sección describiremos cómo unimos todas estas funciones para que la ETL Pipeline funcione como debería, así como el proceso que seguimos para que la información se mantenga actualizada. 4.3.4 Arquitectura final y gestión de su actualización A continuación definiremos la estructura que sigue la ETL Pipeline para aportarnos los datos de los que la aplicación de gráficos interactivos se alimenta. # Extraemos los inmuebles, los asociamos a sus distritos y los almacenamos en Dropbox propertiesData = getPropertiesData() properties = assignDistrictsToProperties(propertiesData) savePropertiesToDBX(properties) # Extraemos las oportunidades, las asociamos a sus distritos y las almacenamos en Dropbox opportunitiesData = getOpportunitiesData() opportunities = assignDistrictsToOpportunities(opportunitiesData) saveOpportunitiesToDBX(opportunities) # Extraemos las propuestas, las asociamos a sus inmuebles y las almacenamos en Dropbox proposalsData = getProposalsData() proposalsData = assignDistrictsToProposals(proposalsData) saveProposalsToDBX(proposalsData) # Agrupamos los datos de las propuestas por distritos y los almacenamos en Dropbox heatmap_data = groupByDistricts(proposalsData) saveHeatmapToDBX(heatmap_data) Figura 4.4: Funciones utilizadas como inputs, transformadores y outputs respectivamente. En lo relativo a la actualización, la realizamos ejecutando la ETL Pipeline los viernes por la tarde, una vez la jornada laboral ha finalizado con el Planificador de tareas de Windows. Esto nos permite ejecutar de manera automática el código semanalmente. ¿Por qué semanalmente? Lo ejecutamos únicamente una vez por semana ya que la información no aumenta de forma notable de un día para otro, y el coste de oportunidad de correr el código es que no se debería utilizar la aplicación de gráficos interactivos mientras la ETL Pipeline está en proceso, y el tiempo de ejecución es de unos cuantos minutos. En el futuro automatizaremos este proceso para poder ejecutarlo desde la nube, permitiéndonos realizar la actualización durante horas no lectivas. "],
["gráficos-interactivos.html", "4.4 Gráficos Interactivos", " 4.4 Gráficos Interactivos 4.4.1 Introducción Teniendo los datos listos para su explotación, a continuación abordaremos la creación de la aplicación para el aprovechamiento de los mismos. Esta sección, por lo tanto, girará en torno al desarrollo de aplicaciones interactivas: explicaremos los diferentes componentes de nuestra aplicación, cómo queremos que interactúen entre sí, cómo deseamos organizar cada uno de los gráficos en la aplicación y, por último, cómo podemos hacer todo esto con ayuda de diferentes librerías de R, principalmente shiny. En la sección 4.1 Fuente de datos, resaltamos la importancia de crear un conjunto de datos para que pueda ser explotado. Ahora es necesario destacar la necesidad de transformar los datos en información comprensible para el usuario a través de un conjunto de gráficos que aporten valor adicional. ¿Cómo podemos aportar valor al usuario a través de una aplicación de gráficos interactivos? Creamos gráficos que respondan a las preguntas más importantes y frecuentes que se pueden hacer los usuarios con respecto a la información dada. Sabiendo qué problema queremos resolver o qué decisión queremos ayudar a tomar, podemos plantearnos qué gráficos mostrar y en torno a qué tipo de información. En nuestro caso, si queremos ayudar a negociar precios, por ejemplo, podremos crear un diagrama de caja que muestre la distribución de los precios en función del número de habitaciones de los inmuebles de una zona concreta. En la próxima sección desarrollaremos este punto. Interactividad entre los componentes de la aplicación para permitir una navegación fácil a través de los datos. Aprovechamos la capacidad de shiny de facilitar la interactividad entre diferentes gráficos, para filtrar de manera automática en el resto de gráficos de la aplicación la información que seleccionamos en uno de ellos. Hablaremos más de este concepto en la sección 4.4.3 Reactividad en Shiny: qué es y cómo explotarla. Filtros para que el usuario pueda acotar tanto como quiera la información obtenible. Como complemento al punto anterior, facilitamos en la aplicación un conjunto de filtros que permiten al usuario la mayor precisión posible a la hora de obtener la información que desea. Experiencia agradable para el usuario. A través de un diseño atractivo y una usabilidad sencilla e intuitiva logramos que el usuario disfrute su experiencia analizando la información mostrada. Esto resulta esencial, ya que buscamos la recurrencia de uso. Acciones no relacionadas directamente con el desarrollo, pero igual de importantes, tales como la recogida de feedback y la corroboración de la fiabilidad de los datos. Pretenden dotar de credibilidad a la aplicación. Si seguimos estos puntos lograremos construir una herramienta que aporte valor al usuario final y añadirá calidad a su toma de decisiones, teniendo un impacto final en la empresa. 4.4.2 Componentes A continuación expondremos los diferentes gráficos que componen la aplicación interactiva, siguiendo la dinámica de la sección 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes. No obstante, en esta sección explicaremos por qué hemos elegido cada tipo de gráfico entre algunas de las alternativas disponibles. Figura 4.5: Mapa de coropletas de los distritos censales de Valencia.Fuente: Elaboración propia para exponer el uso del mapa. Como hemos visto antes, el primer gráfico con el que nos encontramos al abrir la aplicación es el mapa de calor. Lo hemos llamado mapa de calor debido al rango de colores del que hace uso que, en función del campo que seleccionemos, será más claro o más oscuro en cada distrito. No obstante, el nombre técnico correcto para este tipo de mapa es mapa de coropletas, o choropleth map, pero utilizamos el término “calor” debido a que es más comprensible y por lo tanto más fácil de utilizar en conversaciones dentro de homyspace. Un mapa de coropletas es un tipo de mapa que está compuesto por regiones delimitadas en el espacio geográfico, en nuestro caso distritos (aunque podrían ser municipios, provincias, etc.), que se colorean de diferentes colores, en general dentro de una misma gama cromática, en función de una variable. La variable (a escoger) para nuestro mapa es número de oportunidades, de inmuebles o de propuestas aceptadas. Hemos elegido este tipo de mapa principalmente por tres razones: Necesidad de crear agrupaciones más pequeñas que las que ya existían en la base de datos de homyspace (la unidad más pequeña es la ciudad), con el propósito de tener información más precisa en función de la geolocalización de la oportunidad, propuesta o inmueble. Necesidad de crear agrupaciones establecidas bajo un consenso común y que sigan una lógica por ciudad, provincia y comunidad autónoma. Esto facilita el entendimiento por parte del usuario. Previamente utilizábamos un algoritmo de agrupación K-means, que no seguía ninguna lógica y agrupaba inmuebles de diferentes ciudades, provincias e incluso comunidades autónomas. Esto dificultaba mucho la comprensión de los datos: si tenemos una agrupación con inmuebles de Getafe y Madrid, y suben los precios de la agrupación, ¿es posible que sólo hayan subido los precios en Madrid? ¿o en Getafe?. Siguiendo la pista del punto anterior, buscábamos agrupaciones que facilitaran la comunicación interdepartamental: “han subido los precios en el distrito 211” vs “han subido los precios en el barrio Salamanca”. Aunque parezca un detalle nimio, sucede que es fundamental. La capacidad de tomar decisiones de manera ágil y rápida depende directamente de la facilidad de aquel que va a tomar la decisión de transmitir la información que desea claramente, sin invertir tiempo explicando conceptos que no impactan directamente en la decisión (como pueden ser qué representa cada número, qué localizaciones engloba cada agrupación, qué lógica se ha seguido para agrupar los inmuebles, etc.) Estas razones hacen del mapa de coropletas un gráfico fácil de entender incluso por usuarios sin conocimientos estadísticos. Esta propiedad elimina cualquier barrera de entrada a su uso, y maximiza el retorno a la inversión de los recursos que exige su desarrollo. Figura 4.6: Gráfico interactivo que muestra la distribución del alquiler de precios en función del número de habitaciones.Fuente: Elaboración propia para exponer el uso del diagrama de caja. Tras el mapa de calor, nos encontramos con dos gráficos en la misma fila. A la izquierda (el más importante) hemos puesto el diagrama de caja segmentado por número de habitaciones. Un diagrama de caja es un gráfico que presenta algunos estadísticos relevantes de la distribución de una variable numérica, a veces segmentada por una segunda variable. En nuestro caso, indicamos la distribución de los precios mensuales segmentada por número de habitaciones. A raíz de un análisis exhaustivo de los precios de la base de datos de homyspace, nos hemos dado cuenta que la existencia de casos anómalos es relativamente abundante en función del distrito y del número de habitaciones. Esto, sumado a la necesidad por parte del usuario no sólo de saber si un inmueble es caro en comparación con la mediana (o la media) de precios del distrito al que pertenece, sino también dónde se sitúa el precio del inmueble en el rango de percentiles de precios del distrito, nos hace requerir de este tipo de gráfica. ¿Por qué necesita el gestor saber en qué rango del percentil se encuentra el precio del inmueble? La razón principal es que facilita la negociación de precios. Es mucho más sencillo justificar una solicitud de reducción del alquiler mensual de un inmueble si va acompañado de datos que lo apoyen: “el precio de tu inmueble es superior al 70% de los inmuebles de las mismas características en la zona” vs “el precio de tu inmueble es caro”. Aportar datos ayuda al propietario a entender por qué debe bajar los precios y, por lo tanto, facilita la cooperación. La introducción de este tipo de gráfico requiere una inversión relativamente pequeña en formación estadística, aunque mayor que para otros tipos de gráficos, ya que varios de los miembros del equipo desconocen (o no dominan) el concepto de percentiles. No obstante, las ventajas superan con creces los inconvenientes, ya que una vez abordada esta barrera de entrada es un tipo de gráfico que aporta muchísima información de forma rápida y comprensible. Figura 4.7: Gráfico interactivo que muestra el número de propuestas aceptadas y rechazadas en función del número de habitaciones.Fuente: Elaboración propia para exponer el uso del gráfico de barras. Figura 4.8: Gráfico interactivo que muestra el número de inmuebles según el número de habitaciones en el distrito.Fuente: Elaboración propia para exponer el uso del gráfico de barras. Figura 4.9: Gráfico interactivo que muestra el porcentaje de inmuebles con y sin iCal en el distrito.Fuente: Elaboración propia para exponer el uso del gráfico de barras. Tras describir el diagrama de caja, todavía nos queda otro gráfico que tratar: el gráfico de barras. Nuestra aplicación contiene tres gráficos de barras diferentes: El primero, a la derecha del diagrama de caja, indica el número de propuestas aceptadas y rechazadas según el número de habitaciones. El segundo, en la fila de abajo a la izquierda, que indica el número de inmuebles disponibles según el número de habitaciones. El tercero, a la derecha del anterior, que indica el porcentaje de inmuebles con y sin iCal. Un diagrama de barras es un tipo de gráfico que representa la frecuencia absoluta (como en el primer y segundo casos) o relativa (tercer caso) de una variable X. A veces podemos segmentar esta variable en función de una segunda variable, como hacemos en la figura 4.7 con la variable X Número de habitaciones y la variable estadoPropuesta. Es un gráfico fácil de entender y que no tiene prácticamente curva de aprendizaje. De ahí que recurramos tanto a él. En la aplicación, sirven tanto un propósito en sí mismos, como pueden ser el segundo y tercer diagrama de barras, que aportan información valiosa sobre el distrito, como un propósito de asistencia o de validación de los datos, como ocurre con el primer gráfico que, aunque aporta información relevante acerca de las propuestas y la conversión según el número de habitaciones del distrito, su función principal es reforzar la validez de las distribuciones de precios del diagrama de caja. Es decir, permite al usuario comprobar si hay el suficiente número de propuestas para los inmuebles con un número de habitaciones concreto como para que la distribución de precios tenga validez estadística. Para la selección y creación de los gráficos, hemos recurrido reiteradamente al recurso The R Graph Gallery 6 , que facilita no sólo decidir qué gráfico encaja más con los tipos de datos que queremos visualizar, sino que también ayuda en su desarrollo mostrándonos el código en R. 4.4.3 Reactividad en Shiny: qué es y cómo aprovecharla Figura 4.10: Imagen que representa el concepto de reactividad. La reactividad es una propiedad muy poderosa de Shiny que, si se aprende a utilizar, multiplica drásticamente el valor de las aplicaciones construidas con esta librería 7. Esta propiedad nos permite interactuar con la aplicación, almacenar momentáneamente esas interacciones y actualizar la aplicación dinámicamente como consecuencia de dichas interacciones. Logramos maximizar la interactividad y el dinamismo de una aplicación Shiny aprovechando sus propiedades de reactividad. Esta característica de Shiny se puede introducir principalmente de dos maneras diferentes: A través de inputs, lo que en nuestra aplicación son los filtros. Cada vez que modificamos uno de los filtros, todos los gráficos mostrados en la figura 4.10 se actualizarán de manera acorde para sólo mostrar la información filtrada. A través de interacciones del usuario con la aplicación. En nuestro caso, almacenamos los clicks del usuario en el mapa de calor y, cada vez que pincha en un distrito, el filtro del distrito se actualiza dejando únicamente el distrito clickado. De esta forma, se activa la reacción indicada en el punto anterior, actualizando los gráficos para mostrar exclusivamente información relacionada con el distrito seleccionado. No obstante, debido a la capacidad de la reactividad de alterar de manera sustancial la experiencia de usuario, debemos planear en qué gráficos la aplicamos y cómo lo hacemos. Si nos excedemos, estaremos afectando la navegación del usuario por la aplicación, ya que la actualización de datos implica un tiempo de carga de los mismos cada vez que la reactividad responde a una interacción. Nos arriesgamos a que el tiempo de carga sea mayor al de exploración de la información. Del mismo modo, desencadenantes de reactividad demasiado complejos pueden dificultar la comprensión del funcionamiento de la aplicación al usuario, lo cual será contraproducente, debido a que reducirá el interés del usuario por recurrir a la misma. Por eso, hemos insertado un nivel de reactividad en la aplicación lo suficientemente alto como para agilizar la exploración de datos por parte del usuario, al mismo tiempo que permitimos que profundice en la información disponible, pero sin aumentar la complejidad hasta el punto que convierta los desencadenantes de la reactividad en una caja negra. Como hemos dicho antes, tenemos dos tipos de desencadenantes: Los filtros. El click en los distritos del mapa de calor. Después de mucha prueba y error, hemos llegado a la conclusión de que demasiada complejidad entorpece la experiencia de usuario. Nos es más rentable maximizar el nivel de sencillez de la aplicación al mismo tiempo que intentamos optimizar su usabilidad. Aquí tenemos un ejemplo de reactividad aplicada a un conjunto de datos datosOriginales. Con la función reactive, convertimos este conjunto de datos estándar en datos que se actualizarán automáticamente cada vez que el filtro se modifique, manteniendo únicamente los datos cuya propiedad pertenezca al filtro seleccionado. Después, el gráfico en cuestión llamará a los datos reactivos (que ahora son una función), y será modificado cada vez que los datos reactivos se actualicen. library(shiny) library(plotly) library(ggplot2) datosReactivos &lt;- reactive({ datosOriginales %&gt;% filter(propiedadDeLosDatos %in% input$filtro) }) output$grafico &lt;- renderPlotly({ datosParaElGrafico &lt;- datosReactivos() p &lt;- ggplot(datosParaElGrafico) ggplotly(p) }) Holtz, Yan. “The R Graph Gallery”. The R Graph Gallery.↩ Concepto de reactividad explicado por los desarrolladores de Shiny↩ "],
["desarrollo-de-la-aplicación-en-shiny.html", "4.5 Desarrollo de la aplicación en Shiny", " 4.5 Desarrollo de la aplicación en Shiny A continuación ilustraremos, sin entrar en un gran nivel de detalle, el proceso de desarrollo de la aplicación en Shiny. Para los que deseen una mayor comprensión del proyecto, el código completo está disponible en la sección 7.2 Desarrollo de la aplicación en Shiny. El desarrollo de una aplicación de Shiny, al igual que el desarrollo de una ETL Pipeline, se puede dividir en diferentes partes. Por lo general, estas secciones son: Carga de librerías. Creación de funciones. Carga y transformación de los datos. Desarrollo de la interfaz de usuario. Desarrollo de los gráficos y de la reactividad (servidor). Siendo todavía más concisos, lo esencial de una aplicación Shiny es la interfaz de usuario y el servidor, ui y server. Con estos dos componentes somos capaces de desarrollar una aplicación de Shiny. El código que se muestra a continuación es todo lo que necesitamos. library(shiny) ui &lt;- fluidPage( titlePanel(&quot;¡Hola Mundo!&quot;), mainPanel( plotOutput(&quot;distPlot&quot;) ) ) server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ x &lt;- faithful[, 2] bins &lt;- seq(min(x), max(x), length.out = 10) hist(x, breaks = bins) }) } shinyApp(ui = ui, server = server) Como podemos ver de forma intuitiva mediante el código, a través de ui indicamos dónde vamos a colocar los componentes de nuestra aplicación. En el ejemplo, estamos señalando cómo queremos añadir el gráfico “distPlot” al panel principal, mainPanel. Será en server donde desarrollemos este gráfico, siempre añadiendo el prefijo output$ al nombre del componente, ya que queremos que su resultado se muestre en la ui al usuario. 4.5.1 Carga de librerías Para empezar, cargamos en memoria las librerías que vamos a utilizar en la aplicación. Podemos agrupar estas librerías en tres categorías: Relacionadas con la visualización de datos. Estas serían plotly (gráficos interactivos), leaflet (mapas interactivos), leaflet.extras (añade funcionalidad a leaflet) y DT (tablas interactivas). Hemos decidido incluir aquí tidyverse, que es en sí misma una agrupación de las librerías más utilizadas, ya que contiene ggplot2, la librería para gráficos externa de R más conocida, aunque también contiene librerías de transformación de datos como dplyr. Relacionadas con Shiny. Aquí tendríamos shiny, shinymanager (permite añadir usuario y contraseña a la aplicación), shinyWidgets (extiende la variedad de widgets que contiene shiny por defecto), shinydashboard (añade una capa de abstracción que permite crear aplicaciones organizadas y estéticamente agradables de forma sencilla) y shinycssloaders (añade animaciones de carga a los gráficos). Relacionadas con la carga (y transformación) de datos. Para esta agrupación tenemos rdrop2 (extraemos datos de Dropbox), sf (convertimos el Shapefile de los distritos en información gestionable) y lubridate (para tratar información relacionada con fechas). 4.5.2 Creación de funciones En lo que a funciones se refiere, crearemos 4 (y una variable) que también pueden ser subdivididas: Utilizaremos toMoney y toPercentage para transformar variables numéricas en variables asociadas a dinero (_ de 5.0 a 5.0€ ) y porcentaje ( de 0.5 a 50% _), respectivamente. Su propósito será estético, ya que únicamente cambiará cómo el usuario ve esa información. loadHeatmap, función que utilizaremos para cargar el mapa de calor, y actualizarlo cada vez que seleccionamos una variable diferente sobre la que basarnos a la hora de colorear los distritos. lang y credentials son funciones asociadas con la pantalla de autentificación del usuario. En lang modificaremos el texto que verá el usuario al abrir la aplicación, credentials establece el usuario y contraseña necesarios para poder acceder a la aplicación. Figura 4.11: Pantalla de autentificación para acceder a la aplicación. 4.5.3 Carga y transformación de los datos En esta etapa de la aplicación nos encargamos de cargar todos los datos de los que vamos a hacer uso, así como transformarlos para poder explotarlos de la manera que deseamos. Cabe señalar que la transformación aquí es mínima, y normalmente consiste en añadir variables que necesitan de agrupaciones dinámicas, etc. La parte más extensa de transformación de datos es delegada, como ya bien sabemos, a la ETL Pipeline. Una vez los datos ya han sido cargados y transformados, estamos listos para empezar a desarrollar los componentes principales de la aplicación. 4.5.4 Desarrollo de la interfaz de usuario El desarrollo de la interfaz de usuario consiste en diseñar cómo el usuario va a comunicarse con el producto que quieres desarrollar, en nuestro caso la aplicación. Hemos optado por desarrollar una interfaz sencilla, con los filtros disponibles en una columna desplegable a la izquierda, dejando en la pantalla principal únicamente los gráficos interactivos. Para ello, hacemos uso de la librería shinydashboard y sus funciones dashboardPage (aplicación en sí), dashboardHeader (aquí introduciremos el logo de homyspace), dashboardBody (en esta función introduciremos los gráficos) y dashboardSidebar (aquí insertaremos los filtros). title &lt;- tags$a(href=&quot;homyspace.com&quot;, tags$img(src=&quot;http://homybrain.com/img/logo.png&quot;, width = &quot;200&quot;)) ui &lt;- secure_app( theme = shinythemes::shinytheme(&quot;flatly&quot;), dashboardPage( title = &quot;homyspace&quot;, dashboardHeader(title = title), dashboardSidebar( ), dashboardBody( tags$head(tags$style(HTML(&#39; .skin-blue .main-header .logo { font-family: &quot;Nexa Bold&quot;; font-size: 24px; color: #000000; background-color: #eeaf30; } /* navbar (rest of the header) */ .skin-blue .main-header .navbar { background-color: #eeaf30; color: #000000; } &#39;))), ) ) ) Con una estructura de la ui o User Interface (interfaz de usuario en inglés) como esta, logramos esta plantilla: Figura 4.12: Plantilla de las aplicaciones shiny utilizadas en homyspace. Una vez establecida la plantilla, iremos rellenando cada una de sus partes con los componentes que deseemos. 4.5.5 Desarrollo de los gráficos y de la reactividad Debido al carácter técnico de esta sección nos vamos a centrar no tanto en el desarrollo en sí, sino en diferentes consejos y pautas a seguir a la hora de realizar una aplicación en Shiny. Seguimos una metodología basada en prueba y error. Cada vez que desarrollamos un nuevo componente, lo testeamos inmediatamente. Del mismo modo, cuando creamos un sistema de reactividad entre diferentes componentes de la aplicación, también lo probamos antes de proseguir con el desarrollo del resto de componentes. En este caso, nos planteamos qué escenarios pueden hacer que la aplicación se caiga y los validamos, así como que la reactividad sólo se da entre los componentes que esperamos y no se producen efectos cascada inesperados. Establecemos nombres claros e inteligibles a cada uno de los componentes de la aplicación, tanto en la ui como en el server. Esto nos ayuda a comprender mejor el código, tanto a nosotros mismos como a posibles compañeros que quieran modificarlo o, simplemente, entenderlo mejor. Para aquellos interesados en profundizar más en el desarrollo de un servidor de Shiny para una aplicación utilizada en el mundo real, el código se encuentra en la sección 7.2 Desarrollo de la aplicación en Shiny. 4.5.6 Publicación de la aplicación Una vez desarrollada la aplicación, es necesario publicarla en la web para que esté disponible para el equipo. RStudio nos proporciona un servicio gestionado de calidad llamado shinyapps.io 8 donde alojaremos la aplicación. Para ello nos registraremos en shinyapps.io y nos identificaremos a través de RStudio. Figura 4.13: Pantalla que vemos en el proceso de publicación de la aplicación. Tras haber realizado este paso, ya podemos afirmar que nuestra aplicación está lista para ser lanzada. No obstante, esto es sólo el principio. Una vez ha sido lanzada, tendremos que seguir los pasos indicados en la sección 3.4.1 Métodos para la difusión del uso de la aplicación. Del mismo modo, raramente la primera versión de una aplicación es la definitiva. A través del feedback por parte del usuario objetivo iremos mejorando el contenido de la aplicación, para que cada vez esté más cerca del valor máximo que los gráficos interactivos pueden aportar para la mejora de la calidad de la toma de decisiones. shinyapps.io↩ "],
["aspecto-final.html", "4.6 Aspecto Final", " 4.6 Aspecto Final Como conclusión, mostramos una demo de la aplicación que hemos desarrollado para este proyecto. Para mantener la privacidad de homyspace, hemos eliminado los ejes x e y de todos los gráficos. "],
["conclusión.html", "5 Conclusión", " 5 Conclusión El desarrollo de esta aplicación ha sido una tarea compleja tanto desde el punto de vista técnico, como de diseño y de investigación. No obstante, la inversión de recursos en la misma ha resultado un éxito, ya que hemos mejorado la calidad de la toma de decisiones de homyspace y facilitado la implantación de aplicaciones basadas en datos, impactado en la cultura de la empresa de manera positiva. Por lo tanto, concluimos este trabajo de fin de grado afirmando que se ha alcanzado tanto el objetivo general como los específicos. Este proyecto sirve no sólo para convencer al lector de la utilidad de los gráficos interactivos, sino como marco de trabajo para el desarrollo de aplicaciones de gráficos interactivos de manera autónoma, ya sea para sí mismo o para la empresa en que trabaja. "],
["aprendizajes.html", "5.1 Aprendizajes", " 5.1 Aprendizajes Hemos mostrado el uso de gráficos interactivos para la ayuda a la toma de decisiones en homyspace, informándonos de en qué situaciones la inversión al desarrollo de aplicaciones basadas en torno a ellos tiene un retorno positivo. Hemos aprendido a explotar la librería shiny para permitir extraer de los datos la información relevante, filtrando la información y recibiendo respuestas de manera inmediata. Hemos ganado capacidad y comprensión tecnológica, y hemos facilitado la implementación de herramientas basadas en datos en el futuro. Al mismo tiempo, hemos abierto las puertas a nuevas áreas de negocio. Algo esencial en una start-up. Hemos transmitido la importancia del desarrollo de ETL Pipelines que faciliten la explotación de datos. Hemos aumentado la calidad de la toma de decisiones en homyspace gracias no sólo a la reducción de las barreras de entrada a la hora de acceder a la información, sino que también hemos implementado el uso de aplicaciones de gráficos interactivos en el proceso de toma de decisiones de otros departamentos de la empresa, teniendo un impacto positivo en la cultura de la misma. Hemos obtenido la capacidad de redactar documentos con la librería bookdown, con la cual está redactado este proyecto. Esto nos permite automatizar la redacción de informes para poder optimizar el tiempo realizando el análisis. Hemos aprendido a desenvolvernos en un campo desconocido. Al principio de este proyecto, no sabíamos siquiera utilizar Shiny. A través de una metodología basada en prueba y error, hemos acabado manejando diferentes tecnologías y coordinándolas para construir una herramienta que aporta valor a usuarios en diferentes departamentos de la empresa. Figura 5.1: Otras aplicaciones de Shiny: Dashboard que muestra las métricas más importantes de cada departamento. Figura 5.2: Otras aplicaciones de Shiny: Dashboard que nos ayuda a analizar el comportamiento de las propuestas recomendadas a través de métodos de aprendizaje automático. "],
["a-mejorar.html", "5.2 A mejorar", " 5.2 A mejorar Añadir a la aplicación la posibilidad de insertar un fichero con la información relacionada con los inmuebles gestionados y que esta se refleje en el mapa de calor, para poder localizar los inmuebles instantáneamente por distritos y poder analizar a qué precios deberían ofertarse. Añadir a la aplicación precios de inmuebles de otras plataformas, para poder saber si estamos siendo competitivos en comparación tanto con nuestros clientes como con nuestros proveedores. Añadir leyenda al mapa de calor que nos permita percibir qué número exacto representa el rango de colores. Mejorar el código de la ETL Pipeline para que sea mantenible a largo plazo. Aprovechar Amazon Web Services para ejecutar la ETL Pipeline en la nube de manera automática. Esto nos permitirá actualizar las fuentes de datos durante horario no lectivo sin necesidad de que haya un ordenador encendido que haga de servidor. "],
["índice-de-figuras.html", "6 Índice de figuras", " 6 Índice de figuras 1. Introducción, Figura 1.1: Mapa de coropletas de los distritos censales de Valencia.Fuente: Elaboración propia. 1.3 Flujo de trabajo de Homyspace, Figura 1.2: Flujo de trabajo de Homyspace. 3 Aplicación de gráficos interactivos para la toma de decisiones, Figura 3.1: Mapa de calor interactivo que muestra la densidad de inmuebles en Valencia. 3.2 Ventajas de los gráficos interactivos frente a los estáticos, Figura 3.2: Gráfico estático que muestra la popularidad de cada prenda por país. 3.2 Ventajas de los gráficos interactivos frente a los estáticos, Figura 3.3: Gráfico dinámico que muestra la popularidad de cada prenda por país. 3.2 Ventajas de los gráficos interactivos frente a los estáticos, Figura 3.4: Mapa de calor estático que muestra la densidad de inmuebles en Valencia. 3.2 Ventajas de los gráficos interactivos frente a los estáticos, Figura 3.5: Mapa de calor interactivo que muestra la densidad de inmuebles en Valencia. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.6: Pantalla principal de lo que vemos al abrir la aplicación. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.7: Pantalla principal de las opciones de coloreado del mapa de calor. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.8: Pantalla principal de los filtros disponibles para decidir qué información mostrar en la aplicación. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.9: Pantalla principal del mapa de calor al abrir la aplicación. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.10: Pantalla principal del mapa de calor zoomeado en Toledo. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.11: Pantalla principal mostrando los gráficos que aparecen inmediatamente después del mapa de calor. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.12: Pantalla principal del diagrama de caja que indica el alquiler de precios en función del número de habitaciones. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.13: Pantalla principal del gráfico de barras que muestra el número de propuestas aceptadas y rechazadas por número de habitaciones. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.14: Pantalla principal mostrando la segunda fila de gráficos que aparece tras el mapa de calor. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.15: Pantalla principal del gráfico de barras que muestra el número de inmuebles por número de habitaciones. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.16: Pantalla principal del gráfico de barras que indica el porcentaje de inmuebles con y sin iCal. 3.3 Aplicación de gráficos interactivos para la toma de decisiones: aspecto y componentes, Figura 3.17: Pantalla principal de la tabla que resume la información por distrito de todas las propuestas. 3.4.2 Captación, Figura 3.18: Pantalla principal de las opciones de coloreado del mapa de calor. 3.4.2 Captación, Figura 3.19: Pantalla principal del dashboard de Kibana utilizado para hacer un análisis superficial del estado de la demanda. 3.4.2 Captación, Figura 3.20: Definiciones de los campos mostrados en el pop-up del mapa de calor. 3.4.2 Captación, Figura 3.21: Mapa de coropletas de los distritos censales de Valencia. 3.4.3 Negociación, Figura 3.22: Gráfico interactivo que muestra la distribución del alquiler de precios en función del número de habitaciones. 3.4.3 Negociación, Figura 3.23: Gráfico interactivo que muestra el número de inmuebles por número de habitaciones en el distrito. 3.4.3 Negociación, Figura 3.24: Gráfico interactivo que muestra el número de propuestas aceptadas y rechazadas en función del número de habitaciones. 3.4.4 Curación, Figura 3.25: Gráfico interactivo que muestra el porcentaje de inmuebles con y sin iCal en el distrito. 3.5 Aplicación como herramienta de inversión, Figura 3.26: Mapa de coropletas de los distritos censales de Valencia con una capa añadida con las localizaciones de los edificios disponibles en los que invertir. 4.1.1 Introducción, Figura 4.1: Imagen que refleja la importancia de la preparación de los datos en un proyecto que gira en torno a los mismos. 4.1.3 Orígenes de datos, Figura 4.2: Imagen que refleja la disolución de las secciones censales del municipio de Valencia a distritos censales. 4.2 Diseño de la Pipeline, Figura 4.3: Estructura de la ETL Pipeline desarrollada para la aplicación. 4.3.4 Arquitectura final y gestión de su actualización, Figura 4.4: Funciones utilizadas como inputs, transformadores y outputs respectivamente. 4.4.2 Componentes, Figura 4.5: Mapa de coropletas de los distritos censales de Valencia. 4.4.2 Componentes, Figura 4.6: Gráfico interactivo que muestra la distribución del alquiler de precios en función del número de habitaciones. 4.4.2 Componentes, Figura 4.7: Gráfico interactivo que muestra el número de propuestas aceptadas y rechazadas en función del número de habitaciones. 4.4.2 Componentes, Figura 4.8: Gráfico interactivo que muestra el número de inmuebles por número de habitaciones en el distrito. 4.4.2 Componentes, Figura 4.9: Gráfico interactivo que muestra el porcentaje de inmuebles con y sin iCal en el distrito. 4.4.3 Reactividad en Shiny: Qué es y cómo aprovecharla, Figura 4.10: Imagen que representa el concepto de reactividad. 4.5.2 Creación de funciones, Figura 4.11: Pantalla de autentificación para acceder a la aplicación. 4.5.4 Desarrollo de la interfaz de usuario, Figura 4.12: Plantilla de las aplicaciones shiny utilizadas en homyspace. 4.5.6 Publicación de la aplicación, Figura 4.13: Pantalla que vemos en el proceso de publicación de la aplicación. 5.1 Aprendizajes, Figura 5.1: Otras aplicaciones de Shiny: Dashboard que muestra las métricas más importantes de cada departamento. 5.1 Aprendizajes, Figura 5.2: Otras aplicaciones de Shiny: Dashboard que nos ayuda a analizar el comportamiento de las propuestas recomendadas a través de métodos de aprendizaje automático. "],
["código.html", "7 Código", " 7 Código Esta sección contiene el código que hemos utilizado tanto para desarrollar la ETL Pipeline como la aplicación en Shiny. "],
["desarrollo-de-la-etl-pipeline.html", "7.1 Desarrollo de la ETL Pipeline", " 7.1 Desarrollo de la ETL Pipeline import os import numpy as np import geopandas as gpd import matplotlib.pyplot as plt import matplotlib.lines as mlines from matplotlib.colors import ListedColormap import earthpy as et distritos = gpd.read_file(&quot;distritos.shp&quot;, SHAPE_RESTORE_SHX = &quot;YES&quot;) # distritos.shp es el # documento descargado del INE distritos_df = distritos.dissolve(by=&quot;CUDIS&quot;) # disolvemos por distrito distritos_df = distritos_df.reset_index() #Guardamos el archivo diferenciado por distritos a Shapefile distritos_df.to_file(&quot;coordenadasDistritos.shp&quot;) from elasticsearch import Elasticsearch, RequestsHttpConnection from elasticsearch_dsl import Search, Q from requests_aws4auth import AWS4Auth import pandas as pd def getData(index, fields, query=None, endpoint = endpoint): # index es el índice al que vamos a llamar. # fields, los campos que queremos extraer. # query es el filtro que podemos aplicar. Por defecto, no aplicamos filtro. # endpoint es la api a través de la cual nos conectamos a Elasticsearch. access_key = accessKey secret_key = secretKey auth=AWS4Auth(access_key, secret_key, region, service) # En Homyspace, Elasticsearch se utiliza como servicio gestionado a través # de Amazon Web Services, de ahí que necesitemos una autentificación adaptada. # Region es la región que vamos a utilizar de AWS, y service el servicio, # en este caso Elasticsearch. es = Elasticsearch( hosts = [{&quot;host&quot;: endpoint, &quot;port&quot;: port}], http_auth=auth, use_ssl=True, verify_certs=True, connection_class=RequestsHttpConnection ) if not query: indexQuery = Search(using=es, index=index).source(includes=fields) data = pd.DataFrame((d.to_dict() for d in indexQuery.scan())) else: indexQuery = Search(using=es, index=index).source(includes=fields)\\ .query(&quot;bool&quot;, filter = query) data = pd.DataFrame((d.to_dict() for d in indexQuery.scan())) # Por último, transforma la respuesta en una matriz de datos que pueda ser utilizada # en Python, y la devuelve return data from elasticsearch import Elasticsearch, RequestsHttpConnection from elasticsearch_dsl import Search, Q from requests_aws4auth import AWS4Auth import dropbox from dropbox.files import WriteMode from dropbox.exceptions import ApiError, AuthError import requests import zipfile, io from zipfile import ZipFile import pandas as pd import numpy as np import geopandas as gpd from shapely.geometry import Point endpoint = endpoint access_key = access_key secret_key = secret_key auth=AWS4Auth(access_key, secret_key, region, &quot;es&quot;) es = Elasticsearch( hosts = [{&quot;host&quot;: endpoint, &quot;port&quot;: 443}], http_auth=auth, use_ssl=True, verify_certs=True, connection_class=RequestsHttpConnection ) def getPropertiesData(): s1 = Search(using=es, index=&quot;property&quot;).source(includes= [&quot;address.locality&quot;, &quot;address.administrativeAreaLevel2&quot;, &quot;address.country&quot;, &quot;id&quot;, &quot;address.geoLocation&quot;] ) propertiesData = pd.DataFrame((d.to_dict() for d in s1.scan())) propertiesData[&quot;country&quot;] = propertiesData.address.apply(lambda x: x.get(&quot;country&quot;)\\ if type(x) is not float else &quot;&quot;) propertiesData[&quot;province&quot;] = propertiesData.address.apply(lambda x: x.get\\ (&quot;administrativeAreaLevel2&quot;) if type(x) is not float else &quot;&quot;) propertiesData = propertiesData[propertiesData.country == &quot;España&quot;] propertiesData(columns={&quot;id&quot;: &quot;propertyId&quot;}, inplace = True) propertiesData[&quot;lon&quot;] = propertiesData.address.apply(lambda x: x.get(&quot;geoLocation&quot;)\\ .get(&quot;lon&quot;) if type(x) is not float else &quot;&quot;) propertiesData[&quot;lat&quot;] = propertiesData.address.apply(lambda x: x.get(&quot;geoLocation&quot;)\\ .get(&quot;lat&quot;) if type(x) is not float else &quot;&quot;) propertiesData[&quot;propertyCity&quot;] = propertiesData.address.apply(lambda x: x.get(&quot;locality&quot;)\\ if type(x) is not float else &quot;&quot;) propertiesData = propertiesData.replace(&quot;Á&quot;, &quot;A&quot;).replace(&quot;á&quot;, &quot;a&quot;).replace(&quot;À&quot;, &quot;A&quot;)\\ .replace(&quot;à&quot;, &quot;a&quot;).replace(&quot;É&quot;, &quot;E&quot;).replace(&quot;é&quot;, &quot;e&quot;).replace(&quot;È&quot;, &quot;E&quot;).replace(&quot;è&quot;, &quot;e&quot;)\\ .replace(&quot;Í&quot;, &quot;I&quot;).replace(&quot;í&quot;, &quot;i&quot;).replace(&quot;Ì&quot;, &quot;I&quot;).replace(&quot;ì&quot;, &quot;i&quot;).replace(&quot;Ó&quot;, &quot;O&quot;)\\ .replace(&quot;ó&quot;, &quot;o&quot;).replace(&quot;Ò&quot;, &quot;O&quot;).replace(&quot;ò&quot;, &quot;o&quot;).replace(&quot;Ú&quot;,&quot;U&quot;).replace(&quot;ú&quot;, &quot;u&quot;)\\ .replace(&quot;Ù&quot;, &quot;U&quot;).replace(&quot;ù&quot;, &quot;u&quot;).replace(&quot;Ñ&quot;, &quot;NY&quot;).replace(&quot;ñ&quot;, &quot;ny&quot;).replace(&quot;Ü&quot;, &quot;U&quot;)\\ .replace(&quot;ü&quot;, &quot;u&quot;) propertiesData = propertiesData.drop([&quot;address&quot;, &quot;country&quot;], axis=1) geometry = propertiesData.apply(lambda x: Point(x.lon, x.lat), axis = 1) propertiesData = gpd.GeoDataFrame(propertiesData, geometry = geometry) return propertiesData def getOpportunitiesData(): s1 = Search(using=es, index=&quot;deal*&quot;).source(includes= [&quot;address.locality&quot;, &quot;address.administrativeAreaLevel2&quot;, &quot;rentalRequestStage&quot;, &quot;address.country&quot;, &quot;id&quot;, &quot;address.geoLocation&quot;] ) opportunitiesData = pd.DataFrame((d.to_dict() for d in s1.scan())) opportunitiesData[&quot;country&quot;] = opportunitiesData.address.apply(lambda x: x.get(&quot;country&quot;)\\ if type(x) is not float else &quot;&quot;) opportunitiesData[&quot;province&quot;] = opportunitiesData.address.apply(lambda x: x.get\\ (&quot;administrativeAreaLevel2&quot;) if type(x) is not float else &quot;&quot;) opportunitiesData = opportunitiesData[opportunitiesData.country == &quot;España&quot;] opportunitiesData[&quot;lon&quot;] = opportunitiesData.address.apply(lambda x: x.get(&quot;geoLocation&quot;)\\ .get(&quot;lon&quot;) if type(x) is not float else &quot;&quot;) opportunitiesData[&quot;lat&quot;] = opportunitiesData.address.apply(lambda x: x.get(&quot;geoLocation&quot;)\\ .get(&quot;lat&quot;) if type(x) is not float else &quot;&quot;) opportunitiesData = opportunitiesData.replace(&quot;Á&quot;, &quot;A&quot;).replace(&quot;á&quot;, &quot;a&quot;).replace(&quot;À&quot;, &quot;A&quot;)\\ .replace(&quot;à&quot;, &quot;a&quot;).replace(&quot;É&quot;, &quot;E&quot;).replace(&quot;é&quot;, &quot;e&quot;).replace(&quot;È&quot;, &quot;E&quot;).replace(&quot;è&quot;, &quot;e&quot;)\\ .replace(&quot;Í&quot;, &quot;I&quot;).replace(&quot;í&quot;, &quot;i&quot;).replace(&quot;Ì&quot;, &quot;I&quot;).replace(&quot;ì&quot;, &quot;i&quot;).replace(&quot;Ó&quot;, &quot;O&quot;)\\ .replace(&quot;ó&quot;, &quot;o&quot;).replace(&quot;Ò&quot;, &quot;O&quot;).replace(&quot;ò&quot;, &quot;o&quot;).replace(&quot;Ú&quot;,&quot;U&quot;).replace(&quot;ú&quot;, &quot;u&quot;)\\ .replace(&quot;Ù&quot;, &quot;U&quot;).replace(&quot;ù&quot;, &quot;u&quot;).replace(&quot;Ñ&quot;, &quot;NY&quot;).replace(&quot;ñ&quot;, &quot;ny&quot;).replace(&quot;Ü&quot;, &quot;U&quot;)\\ .replace(&quot;ü&quot;, &quot;u&quot;) opportunitiesData = opportunitiesData.drop([&quot;address&quot;, &quot;country&quot;], axis=1) geometry = opportunitiesData.apply(lambda x: Point(x.lon, x.lat), axis = 1) opportunitiesData = gpd.GeoDataFrame(opportunitiesData, geometry = geometry) return opportunitiesData def getProposalsData(): statusQuery = Q(&quot;match&quot;, proposalStatus = &quot;OK&quot;) acceptedQuery = Q(&quot;match&quot;, proposalStage = &quot;ACCEPTED&quot;) rejectedQuery = Q(&quot;match&quot;, proposalStage = &quot;REJECTED&quot;) completeQuery = statusQuery &amp; (acceptedQuery | rejectedQuery) s1 = Search(using=es, index=&quot;proposal*&quot;).source(includes= [&quot;address.locality&quot;, &quot;address.administrativeAreaLevel2&quot;, &quot;address.postalCode&quot;, &quot;dateCheckIn&quot;, &quot;dateCheckOut&quot;, &quot;monthlyPriceDossier.amount&quot;, &quot;property.beds&quot;, &quot;proposalStage&quot;, &quot;proposalStatus&quot;, &quot;property.id&quot;, &quot;creationDate&quot;, &quot;address.geoLocation&quot;] ).query(&quot;bool&quot;, filter = completeQuery) proposalsData = pd.DataFrame((d.to_dict() for d in s1.scan())) proposalsData = proposalsData[(proposalsData.dateCheckIn &gt; 0) &amp;\\ (proposalsData.dateCheckOut &gt; 0)] proposalsData[&quot;propertyId&quot;] = proposalsData.property.apply(lambda x: x.get(&quot;id&quot;)\\ if type(x) is not float else &quot;&quot;) proposalsData[&quot;propertyCity&quot;] = proposalsData.address.apply(lambda x: x.get(&quot;locality&quot;)\\ if type(x) is not float else &quot;&quot;) proposalsData[&quot;province&quot;] = proposalsData.address.apply(lambda x: x.get\\ (&quot;administrativeAreaLevel2&quot;) if type(x) is not float else &quot;&quot;) proposalsData[&quot;monthlyPrice&quot;] = proposalsData.monthlyPriceDossier.apply(lambda x: x.get\\ (&quot;amount&quot;) if type(x) is not float else &quot;&quot;) proposalsData[&quot;dateCheckIn&quot;] = pd.to_datetime(proposalsData[&quot;dateCheckIn&quot;], unit = &quot;ms&quot;) proposalsData[&quot;dateCheckOut&quot;] = pd.to_datetime(proposalsData[&quot;dateCheckOut&quot;], unit = &quot;ms&quot;) proposalsData[&quot;beds&quot;] = proposalsData.property.apply(lambda x: x.get(&quot;beds&quot;)\\ if type(x) is not float else &quot;&quot;) proposalsData[&quot;duration&quot;] = (proposalsData[&quot;dateCheckOut&quot;] - proposalsData[&quot;dateCheckIn&quot;])\\ .dt.days proposalsData = proposalsData.drop( [&quot;property&quot;, &quot;proposalStatus&quot;, &quot;address&quot;, &quot;monthlyPriceDossier&quot;, &quot;creationDate&quot;, &quot;dateCheckIn&quot;, &quot;dateCheckOut&quot;], axis=1 ) proposalsData = proposalsData.replace(&quot;Á&quot;, &quot;A&quot;).replace(&quot;á&quot;, &quot;a&quot;).replace(&quot;À&quot;, &quot;A&quot;)\\ .replace(&quot;à&quot;, &quot;a&quot;).replace(&quot;É&quot;, &quot;E&quot;).replace(&quot;é&quot;, &quot;e&quot;).replace(&quot;È&quot;, &quot;E&quot;).replace(&quot;è&quot;, &quot;e&quot;)\\ .replace(&quot;Í&quot;, &quot;I&quot;).replace(&quot;í&quot;, &quot;i&quot;).replace(&quot;Ì&quot;, &quot;I&quot;).replace(&quot;ì&quot;, &quot;i&quot;).replace(&quot;Ó&quot;, &quot;O&quot;)\\ .replace(&quot;ó&quot;, &quot;o&quot;).replace(&quot;Ò&quot;, &quot;O&quot;).replace(&quot;ò&quot;, &quot;o&quot;).replace(&quot;Ú&quot;,&quot;U&quot;).replace(&quot;ú&quot;, &quot;u&quot;)\\ .replace(&quot;Ù&quot;, &quot;U&quot;).replace(&quot;ù&quot;, &quot;u&quot;).replace(&quot;Ñ&quot;, &quot;NY&quot;).replace(&quot;ñ&quot;, &quot;ny&quot;).replace(&quot;Ü&quot;, &quot;U&quot;)\\ .replace(&quot;ü&quot;, &quot;u&quot;) return proposalsData def getDistrictsFromDBX(zip_file_url): zip_file_url = zip_file_url r = requests.get(zip_file_url) z = zipfile.ZipFile(io.BytesIO(r.content)) z.extractall() distritos = gpd.GeoDataFrame.from_file(&quot;coordenadasDistritos.shp&quot;) distritos = distritos.to_crs(epsg = 4326) # distritos = distritos.replace(&quot;Araba/Álava&quot;, &quot;Álava&quot;)\\ # .replace(&quot;Balears, Illes&quot;, &quot;Illes Balears&quot;)\\ # .replace(&quot;Castellón/Castelló&quot;, &quot;Castellón&quot;)\\ # .replace(&quot;Coruña, A&quot;, &quot;A Coruña&quot;)\\ # .replace(&quot;Rioja, La&quot;, &quot;La Rioja&quot;)\\ # .replace(&quot;Palmas, Las&quot;, &quot;Las Palmas&quot;)\\ # .replace(&quot;Valencia/Valéncia&quot;, &quot;Valencia&quot;) return distritos def getPropertiesFromDBX(zip_file_url): zip_file_url = zip_file_url r = requests.get(zip_file_url) z = zipfile.ZipFile(io.BytesIO(r.content)) z.extractall() propertiesGeometry = gpd.GeoDataFrame.from_file(&quot;properties.shp&quot;) return propertiesGeometry def getOpportunitiesFromDBX(url): opportunitiesDistritos = pd.read_csv(url) opportunitiesDistritos.drop(&quot;Unnamed: 0&quot;, axis = 1, inplace = True) return opportunitiesDistritos def assignDistrictsToProperties(propertiesData): propertiesGeometry = getPropertiesFromDBX() distritos = getDistrictsFromDBX() propertiesData = propertiesData[~propertiesData[&quot;propertyId&quot;]\\ .isin(propertiesGeometry[&quot;propertyId&quot;])].reset_index() properties = propertiesData.copy() properties[&quot;distrito&quot;] = np.nan properties[&quot;municipio&quot;] = np.nan properties[&quot;polygon&quot;] = np.nan length = properties.shape[0] totales = 0 sumat = 0 for i, inmueble in properties.iterrows(): provincia = inmueble.province point = inmueble.geometry distritosProvincia = distritos[distritos.NPRO == provincia] for j, distrito in distritosProvincia.iterrows(): geom = distrito.geometry cudis = distrito.CUDIS nmun = distrito.NMUN if geom.contains(point): properties[&quot;distrito&quot;].loc[i] = cudis properties[&quot;municipio&quot;].loc[i] = nmun properties[&quot;polygon&quot;].loc[i] = geom break totales += 1 if totales == 100: sumat += totales totales = 0 print(str(sumat) + &quot; completados de &quot; + str(length)) properties.drop(columns=[&quot;geometry&quot;, &quot;index&quot;], inplace = True) properties.rename(columns={&quot;polygon&quot;: &quot;geometry&quot;}, inplace = True) properties = gpd.GeoDataFrame(properties, geometry = properties.geometry) properties = properties[[&quot;propertyId&quot;, &quot;municipio&quot;, &quot;distrito&quot;, &quot;geometry&quot;]] properties = pd.concat([propertiesGeometry, properties], sort = True) properties = properties.drop_duplicates(subset = &quot;propertyId&quot;) return properties def assignDistrictsToOpportunities(opportunitiesData): opportunitiesDistritos = getOpportunitiesFromDBX(url) opportunitiesData = opportunitiesData[~opportunitiesData[&quot;id&quot;]\\ .isin(opportunitiesDistritos[&quot;id&quot;])].reset_index() opportunitiesData.drop(columns=[&quot;index&quot;], inplace=True) distritos = gpd.GeoDataFrame.from_file(&quot;coordenadasDistritos.shp&quot;) distritos = distritos.to_crs(epsg = 4326) # distritos = distritos.replace(&quot;Araba/Álava&quot;, &quot;Álava&quot;)\\ # .replace(&#39;Balears, Illes&#39;, &quot;Illes Balears&quot;)\\ # .replace(&#39;Castellón/Castelló&#39;, &quot;Castellón&quot;)\\ # .replace(&#39;Coruña, A&#39;, &quot;A Coruña&quot;)\\ # .replace(&#39;Rioja, La&#39;, &quot;La Rioja&quot;)\\ # .replace(&#39;Palmas, Las&#39;, &quot;Las Palmas&quot;)\\ # .replace(&#39;Valencia/Valéncia&#39;, &quot;Valencia&quot;) opportunities = opportunitiesData.copy() opportunities[&quot;distrito&quot;] = np.nan opportunities[&quot;municipio&quot;] = np.nan length = opportunities.shape[0] totales = 0 sumat = 0 for i, opportunity in opportunities.iterrows(): provincia = opportunity.province point = opportunity.geometry distritosProvincia = distritos[distritos.NPRO == provincia] for j, distrito in distritosProvincia.iterrows(): geom = distrito.geometry cudis = distrito.CUDIS nmun = distrito.NMUN if geom.contains(point): opportunities[&quot;distrito&quot;].loc[i] = cudis opportunities[&quot;municipio&quot;].loc[i] = nmun break totales += 1 if totales == 100: sumat += totales totales = 0 print(str(sumat) + &quot; completados de &quot; + str(length)) opportunities.drop(columns=[&quot;geometry&quot;, &quot;lon&quot;, &quot;lat&quot;], inplace = True) opportunities[&quot;distrito&quot;] = opportunities.distrito.astype(str) opportunities[&quot;distrito&quot;] = opportunities.distrito + &quot;x&quot; opportunities = pd.concat([opportunitiesDistritos, opportunities], sort = True) return opportunities def assignDistrictsToProposals(proposalsData): properties = getPropertiesFromDBX() proposalsData = proposalsData.merge(properties, how = &quot;left&quot;, on = &quot;propertyId&quot;) proposalsData = gpd.GeoDataFrame(proposalsData, geometry = proposalsData.geometry) return proposalsData def groupByDistricts(proposalsData): opportunities = getOpportunitiesFromDBX() pricePerRooms = proposalsData.dropna(subset=[&quot;monthlyPrice&quot;]).groupby([&quot;distrito&quot;, &quot;rooms&quot;])\\ [&quot;monthlyPrice&quot;].median().reset_index()\\ .pivot(index = &quot;distrito&quot;, columns = &quot;rooms&quot;, values = &quot;monthlyPrice&quot;).reset_index() proposalsNumber = proposalsData.groupby(&quot;distrito&quot;)[&quot;proposalStage&quot;].count().reset_index()\\ .sort_values(by=&quot;proposalStage&quot;, ascending = False)\\ .rename(columns = {&quot;proposalStage&quot;: &quot;proposalsNumber&quot;}) propertiesProposedPerDistrict = proposalsData.groupby(&quot;distrito&quot;)[&quot;propertyId&quot;]\\ .nunique().reset_index().rename(columns = {&quot;propertyId&quot;: &quot;numberPropertiesProposed&quot;}) propertiesAcceptedPerDistrict = proposalsData[proposalsData.proposalStage == &quot;ACCEPTED&quot;]\\ .groupby(&quot;distrito&quot;)[&quot;propertyId&quot;].nunique().reset_index()\\ .rename(columns = {&quot;propertyId&quot;: &quot;numberPropertiesAccepted&quot;}) propertiesPerDistrict = properties[[&quot;distrito&quot;, &quot;propertyId&quot;]]\\ .groupby(&quot;distrito&quot;).count().reset_index().rename(columns={&quot;propertyId&quot;: &quot;numberProperties&quot;}) acceptedProposalsNumber = proposalsData[proposalsData.proposalStage == &quot;ACCEPTED&quot;]\\ .groupby(&quot;distrito&quot;)[&quot;proposalStage&quot;].count().reset_index()\\ .sort_values(by=&quot;proposalStage&quot;, ascending = False)\\ .rename(columns = {&quot;proposalStage&quot;: &quot;acceptedProposalsNumber&quot;}) durationPerDistrict = proposalsData.groupby(&quot;distrito&quot;)[&quot;duration&quot;].median().reset_index() opportunitiesPerDistrict = opportunities.groupby(&quot;distrito&quot;)[&quot;id&quot;].count().reset_index()\\ .rename(columns={&quot;id&quot;: &quot;numOpportunities&quot;})\\ .sort_values(ascending = False, by = &quot;numOpportunities&quot;) bookingsPerDistrict = opportunities\\ [(opportunities.rentalRequestStage == &quot;S030_CONTRACT_INVOICE_MANAGMENT&quot;)\\ | (opportunities.rentalRequestStage ==&quot;S040_CHECK_IN&quot;) | \\ (opportunities.rentalRequestStage == &quot;S050_RENTAL_CONFIRMED&quot;) | \\ (opportunities.rentalRequestStage ==&quot;S060_CONVERSION_HISTORY&quot;)]\\ .groupby(&quot;distrito&quot;)[&quot;id&quot;].count().reset_index().rename(columns={&quot;id&quot;: &quot;numBookings&quot;})\\ .sort_values(ascending = False, by = &quot;numBookings&quot;) distritos = proposalsData[[&quot;distrito&quot;, &quot;geometry&quot;, &quot;municipio&quot;, &quot;propertyCity&quot;]]\\ .drop_duplicates(subset = &quot;distrito&quot;) heatmap_data = proposalsNumber.merge(acceptedProposalsNumber, how = &quot;left&quot;, on =&quot;distrito&quot;)\\ .merge(propertiesPerDistrict, how = &quot;left&quot;, on = &quot;distrito&quot;)\\ .merge(propertiesProposedPerDistrict, how = &quot;left&quot;, on = &quot;distrito&quot;)\\ .merge(propertiesAcceptedPerDistrict, how = &quot;left&quot;, on = &quot;distrito&quot;)\\ .merge(durationPerDistrict, how = &quot;left&quot;, on = &quot;distrito&quot;)\\ .merge(pricePerRooms, how = &quot;left&quot;, on = &quot;distrito&quot;)\\ .merge(opportunitiesPerDistrict, how = &quot;left&quot;, on = &quot;distrito&quot;)\\ .merge(bookingsPerDistrict, how = &quot;left&quot;, on = &quot;distrito&quot;)\\ .merge(distritos, how = &quot;left&quot;, on = &quot;distrito&quot;)\\ heatmap_data = gpd.GeoDataFrame(heatmap_data, geometry = heatmap_data.geometry) heatmap_data[&quot;conversionRatio&quot;] = heatmap_data[&quot;numBookings&quot;]\\ /heatmap_data[&quot;numOpportunities&quot;] heatmap_data[&quot;benchmark&quot;] = heatmap_data[&quot;acceptedProposalsNumber&quot;]\\ /heatmap_data[&quot;proposalsNumber&quot;] heatmap_data[&quot;propertiesUsed&quot;] = heatmap_data[&quot;numberPropertiesProposed&quot;]\\ /heatmap_data[&quot;numberProperties&quot;] heatmap_data[&quot;propertiesConverted&quot;] = heatmap_data[&quot;numberPropertiesAccepted&quot;]\\ /heatmap_data[&quot;numberPropertiesProposed&quot;] heatmap_data[&quot;distrito&quot;] = heatmap_data.distrito.astype(str) return heatmap_data # Access token TOKEN = TOKEN # Uploads contents of LOCALFILE to Dropbox def backup(): with open(LOCALFILE, &#39;rb&#39;) as f: print(&quot;Uploading &quot; + LOCALFILE + &quot; to Dropbox as &quot; + BACKUPPATH + &quot;...&quot;) try: dbx = dropbox.Dropbox(TOKEN) dbx.files_upload(f.read(), BACKUPPATH, mode=WriteMode(&#39;overwrite&#39;)) except ApiError as err: if err.user_message_text: print(err.user_message_text) sys.exit() else: print(err) sys.exit() # Adding few functions to check file details def checkFileDetails(): print(&quot;Checking file details&quot;) for entry in dbx.files_list_folder(&#39;&#39;).entries: print(&quot;File list is : &quot;) print(entry.name) # Run this script independently def uploadDropbox(TOKEN, LOCALFILE, BACKUPPATH): if __name__ == &#39;__main__&#39;: # Check for an access token if (len(TOKEN) == 0): sys.exit(&quot;ERROR: Looks like you didn&#39;t add your access token.\\ Open up backup-and-restore-example.py in a text editor and paste in your token in line 14.&quot;) # Create an instance of a Dropbox class, which can make requests to the API. print(&quot;Creating a Dropbox object...&quot;) dbx = dropbox.Dropbox(TOKEN) print(&quot;Creating backup...&quot;) # Create a backup of the current settings file backup() print(&quot;Done!&quot;) def savePropertiesToDBX(properties): properties.to_file(&quot;properties.shp&quot;) filename = &quot;properties.zip&quot; with ZipFile(filename, &quot;w&quot;) as zip: for file in [&quot;properties.shp&quot;, &quot;properties.cpg&quot;, &quot;properties.dbf&quot;, &quot;properties.shx&quot;]: zip.write(file) LOCALFILE = &quot;properties.zip&quot; BACKUPPATH = &quot;/properties.zip&quot; uploadDropbox(TOKEN, LOCALFILE, BACKUPPATH) def saveOpportunitiesToDBX(opportunities): opportunities.to_csv(&quot;opportunities.csv&quot;) LOCALFILE = &quot;opportunities.csv&quot; BACKUPPATH = &quot;/opportunities.csv&quot; uploadDropbox(TOKEN, LOCALFILE, BACKUPPATH) def saveHeatmapToDBX(heatmap_data): heatmap_data.to_file(&quot;heatmap.shp&quot;) filename = &quot;heatmap.zip&quot; with ZipFile(filename, &quot;w&quot;) as zip: for file in [&quot;heatmap.shp&quot;, &quot;heatmap.cpg&quot;, &quot;heatmap.dbf&quot;, &quot;heatmap.shx&quot;]: zip.write(file) LOCALFILE = &quot;heatmap.zip&quot; BACKUPPATH = &quot;/heatmap.zip&quot; uploadDropbox(TOKEN, LOCALFILE, BACKUPPATH) def saveProposalsToDBX(proposalsData): proposalsData.drop(columns=[&quot;geometry&quot;], inplace = True) proposalsData[&quot;distrito&quot;] = proposalsData.distrito.astype(str) proposalsData.to_csv(&quot;proposalsData.csv&quot;) LOCALFILE = &quot;proposalsData.csv&quot; BACKUPPATH = &quot;/proposalsData.csv&quot; uploadDropbox(TOKEN, LOCALFILE, BACKUPPATH) "],
["desarrollo-de-la-aplicación-en-shiny-1.html", "7.2 Desarrollo de la aplicación en Shiny", " 7.2 Desarrollo de la aplicación en Shiny ##### ##### Carga de librerías # Relacionados con la visualización (y transformación) de datos library(tidyverse) library(plotly) library(leaflet) library(leaflet.extras) library(DT) # Relacionados con Shiny library(shiny) library(shinymanager) library(shinyWidgets) library(shinydashboard) library(shinycssloaders) # Relacionados con la carga (y transformación) de datos library(rdrop2) library(sf) library(lubridate) ##### ##### Creación de funciones # Funciones y variables para la pantalla de acceso lang &lt;- shinymanager:::language$new() lang$add( &quot;Please authenticate&quot; = &quot;Bienvenid@ al mapa de calor!&quot; ) credentials &lt;- data.frame( user = &quot;&quot;, password = &quot;&quot;, stringsAsFactors = FALSE ) # Funciones para la transformación de datos toPercentage &lt;- function(value) { return(paste0(round(100*value,2),&#39;%&#39;)) } toMoney &lt;- function(value) { return(paste0(round(value,2),&#39; euro&#39;)) } # Función para crear el mapa de calor, y alterar el rango de colores en función del campo seleccionado loadHeatmap &lt;- function(mapData, campoColor) { if (campoColor == &quot;Número de Oportunidades&quot;) { colorSeleccionado = &quot;numOpportunities&quot; bins &lt;- c(0, 5, 10, 15, 20, 25, 50, 75, 100, Inf) } else if (campoColor == &quot;Número de Inmuebles&quot;) { colorSeleccionado = &quot;numberProperties&quot; bins &lt;- c(0, 5, 10, 15, 20, 25, 50, 75, 100, Inf) } else if (campoColor == &quot;Número de Propuestas Aceptadas&quot;) { colorSeleccionado = &quot;acceptedProposals&quot; bins &lt;- c(0, 5, 10, 15, 20, 25, 50, 75, 100, Inf) } pal &lt;- colorBin(&quot;YlOrRd&quot;, domain = mapData[[colorSeleccionado]], bins = bins) mapData %&gt;% leaflet() %&gt;% setView(lng = -3.6, lat = 40.45, zoom = 5) %&gt;% addTiles() %&gt;% addPolygons( layerId = ~distrito, label = ~distrito, popup = ~relevantInfo, fillColor = ~pal(mapData[[colorSeleccionado]]), color = &quot;#444444&quot;, weight = 1, smoothFactor = 0.5, opacity = 1.0, fillOpacity = 0.5, highlightOptions = highlightOptions(color = &quot;white&quot;, weight = 2, bringToFront = TRUE) ) %&gt;% # addTiles() %&gt;% # addAwesomeMarkers( # data = inmuebles, # lng = ~lon, # lat = ~lat, # label = ~BX.ID, # layerId = ~distrito, # popup = ~relevantInfo # ) %&gt;% addSearchOSM(options = searchOptions(autoCollapse = TRUE, minLength = 2)) } ##### ##### Carga y transformación de los datos # Carga de la shapefile con los distritos token &lt;- readRDS(&quot;droptoken.rds&quot;) drop_download(&quot;/heatmap.zip&quot;, dtoken = token, overwrite = T) unzip(&quot;heatmap.zip&quot;) polyData &lt;- read_sf(dsn = path.expand(&quot;heatmap.shp&quot;), layer=&quot;heatmap&quot;) polyData &lt;- polyData %&gt;% rename( &quot;proposalsNumber&quot; = &quot;proposalsN&quot;, &quot;acceptedProposals&quot; = &quot;acceptedPr&quot;, &quot;numberProperties&quot; = &quot;numberProp&quot;, &quot;0_rooms&quot; = &quot;X0.0&quot;, &quot;1_rooms&quot; = &quot;X1.0&quot;, &quot;2_rooms&quot; = &quot;X2.0&quot;, &quot;3_rooms&quot; = &quot;X3.0&quot;, &quot;4_rooms&quot; = &quot;X4.0&quot;, &quot;more4_rooms&quot; = &quot;X.4&quot;, &quot;propertyCity&quot; = &quot;propertyCi&quot;, &quot;numberPropertiesProposed&quot; = &quot;numberPr_1&quot;, &quot;numberPropertiesConverted&quot; = &quot;numberPr_2&quot;, &quot;percentagePropertiesProposed&quot; = &quot;properties&quot;, &quot;conversionRatioProperties&quot; = &quot;properti_1&quot;, &quot;numOpportunities&quot; = &quot;numOpportu&quot;, &quot;numBookings&quot; = &quot;numBooking&quot;, &quot;conversionRatio&quot; = &quot;conversion&quot; ) polyData$propertyCity &lt;- factor(polyData$propertyCity) polyData$municipio &lt;- factor(polyData$municipio) polyData$distrito &lt;- factor(polyData$distrito) polyData$`12_rooms` &lt;- (polyData$`1_rooms` + polyData$`2_rooms`)/2 # Creación del texto que aparecerá al clickar en el distrito polyData$relevantInfo &lt;- paste(&quot;&lt;strong&gt;Distrito:&lt;/strong&gt;&quot;, polyData$distrito, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Oportunidades:&lt;/strong&gt;&quot;, polyData$numOpportunities, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Reservas:&lt;/strong&gt;&quot;, polyData$numBookings, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Ratio de Conversión:&lt;/strong&gt;&quot;, toPercentage(polyData$conversionRatio), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles:&lt;/strong&gt;&quot;, polyData$numberProperties, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles propuestos:&lt;/strong&gt;&quot;, polyData$numberPropertiesProposed, paste(&quot;(&quot;, toPercentage(polyData$percentagePropertiesProposed), &quot;)&quot;, sep = &quot;&quot;), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles reservados:&lt;/strong&gt;&quot;, polyData$numberPropertiesConverted, paste(&quot;(&quot;, toPercentage(polyData$conversionRatioProperties), &quot;)&quot;, sep = &quot;&quot;), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Propuestas Hechas:&lt;/strong&gt;&quot;, polyData$proposalsNumber, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Propuestas Aceptadas:&lt;/strong&gt;&quot;, polyData$acceptedProposals, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Benchmark:&lt;/strong&gt;&quot;, toPercentage(polyData$benchmark), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Precio Medio (1 y 2 habitaciones):&lt;/strong&gt;&quot;, toMoney(polyData$`12_rooms`), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Estancia Media:&lt;/strong&gt;&quot;, polyData$duration) # Carga de los csv de los que se alimentarán los gráficos heatmapData &lt;- drop_read_csv(&quot;/heatmapData.csv&quot;, dtoken = token) heatmapData$distrito &lt;- factor(heatmapData$distrito) heatmapData$rooms &lt;- factor(heatmapData$rooms) heatmapData$beds &lt;- factor(as.integer(heatmapData$beds)) heatmapData$duration &lt;- round(heatmapData$duration) properties &lt;- drop_read_csv(&quot;/properties.csv&quot;, dtoken = token) properties$distrito &lt;- factor(properties$distrito) properties$distrito &lt;- gsub(&quot;x&quot;, &quot;&quot;, properties$distrito) properties$distrito &lt;- gsub(&quot;None&quot;, NA, properties$distrito) properties$distrito &lt;- factor(properties$distrito) properties$rooms &lt;- factor(properties$rooms) properties$hasICal &lt;- as.logical(properties$hasICal) properties$municipio &lt;- factor(properties$municipio) # Carga de información de inversores, si tuviéramos inmuebles &lt;- read.csv(&quot;inmuebles.csv&quot;, encoding=&quot;UTF-8&quot;) inmuebles &lt;- inmuebles %&gt;% rename( &quot;proposalsNumber&quot; = &quot;proposalsN&quot;, &quot;acceptedProposals&quot; = &quot;acceptedPr&quot;, &quot;numberProperties&quot; = &quot;numberProp&quot;, &quot;0_rooms&quot; = &quot;X0.0&quot;, &quot;1_rooms&quot; = &quot;X1.0&quot;, &quot;2_rooms&quot; = &quot;X2.0&quot;, &quot;3_rooms&quot; = &quot;X3.0&quot;, &quot;4_rooms&quot; = &quot;X4.0&quot;, &quot;more4_rooms&quot; = &quot;X.4&quot;, &quot;propertyCity&quot; = &quot;propertyCi&quot;, &quot;numberPropertiesProposed&quot; = &quot;numberPr_1&quot;, &quot;numberPropertiesConverted&quot; = &quot;numberPr_2&quot;, &quot;percentagePropertiesProposed&quot; = &quot;properties&quot;, &quot;conversionRatioProperties&quot; = &quot;properti_1&quot;, &quot;numOpportunities&quot; = &quot;numOpportu&quot;, &quot;numBookings&quot; = &quot;numBooking&quot;, &quot;conversionRatio&quot; = &quot;conversion&quot; ) inmuebles$lon &lt;- as.numeric(inmuebles$lon) inmuebles$lat &lt;- as.numeric(inmuebles$lat) inmuebles$`1_rooms` &lt;- as.numeric(inmuebles$`1_rooms`) inmuebles$`2_rooms` &lt;- as.numeric(inmuebles$`2_rooms`) inmuebles$`12_rooms` &lt;- (inmuebles$`1_rooms` + inmuebles$`2_rooms`)/2 inmuebles$relevantInfo &lt;- paste( &quot;&lt;strong&gt;ID:&lt;/strong&gt;&quot;, inmuebles$BX.ID, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles 0 habitaciones:&lt;/strong&gt;&quot;, inmuebles$X0D.Units, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles 1 habitaciones:&lt;/strong&gt;&quot;, inmuebles$X1D.Units, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles 2 habitaciones:&lt;/strong&gt;&quot;, inmuebles$X2D.Units, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles 3 habitaciones:&lt;/strong&gt;&quot;, inmuebles$X3D.Units, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles 4 habitaciones:&lt;/strong&gt;&quot;, inmuebles$X4D.Units, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles 5 habitaciones:&lt;/strong&gt;&quot;, inmuebles$X5D.Units, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Capex:&lt;/strong&gt;&quot;, inmuebles$capex, &quot;&lt;br&gt;&quot;, &quot;&lt;hr&gt;&quot;, &quot;&lt;strong&gt;Distrito:&lt;/strong&gt;&quot;, inmuebles$distrito, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Oportunidades:&lt;/strong&gt;&quot;, inmuebles$numOpportunities, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Reservas:&lt;/strong&gt;&quot;, inmuebles$numBookings, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Ratio de Conversión:&lt;/strong&gt;&quot;, toPercentage(inmuebles$conversionRatio), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles:&lt;/strong&gt;&quot;, inmuebles$numberProperties, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles propuestos:&lt;/strong&gt;&quot;, inmuebles$numberPropertiesProposed, paste(&quot;(&quot;, toPercentage(inmuebles$percentagePropertiesProposed), &quot;)&quot;, sep = &quot;&quot;), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Inmuebles reservados:&lt;/strong&gt;&quot;, inmuebles$numberPropertiesConverted, paste(&quot;(&quot;, toPercentage(inmuebles$conversionRatioProperties), &quot;)&quot;, sep = &quot;&quot;), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Propuestas Hechas:&lt;/strong&gt;&quot;, inmuebles$proposalsNumber, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Propuestas Aceptadas:&lt;/strong&gt;&quot;, inmuebles$acceptedProposals, &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Benchmark:&lt;/strong&gt;&quot;, toPercentage(inmuebles$benchmark), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Precio Medio (1 y 2 habitaciones):&lt;/strong&gt;&quot;, toMoney(inmuebles$`12_rooms`), &quot;&lt;br&gt;&quot;, &quot;&lt;strong&gt;Estancia Media:&lt;/strong&gt;&quot;, inmuebles$duration) ##### ##### Diseño de la interfaz de usuario title &lt;- tags$a(href=&quot;homyspace.com&quot;, tags$img(src=&quot;http://homybrain.com/img/logo.png&quot;, width = &quot;200&quot;)) ui &lt;- secure_app( theme = shinythemes::shinytheme(&quot;flatly&quot;), dashboardPage( title = &quot;homyspace&quot;, dashboardHeader(title = title), dashboardSidebar( collapsed = T, pickerInput(inputId = &quot;propertyCity&quot;, label = &quot;Filtra por ciudad&quot;, choices = levels(polyData$propertyCity), selected = levels(polyData$propertyCity), multiple = T, options = list( `actions-box` = TRUE, size = 10, `live-search` = TRUE )), pickerInput(inputId = &quot;municipio&quot;, label = &quot;Filtra por municipio&quot;, choices = levels(polyData$municipio), selected = levels(polyData$municipio), multiple = T, options = list( `actions-box` = TRUE, size = 10, `live-search` = TRUE )), pickerInput(inputId = &quot;distrito&quot;, label = &quot;Filtra por distrito&quot;, choices = levels(polyData$distrito), selected = levels(polyData$distrito), multiple = T, options = list( `actions-box` = TRUE, size = 10, `live-search` = TRUE )), pickerInput(inputId = &quot;beds&quot;, label = &quot;Filtra por número de camas&quot;, choices = levels(heatmapData$beds), selected = levels(heatmapData$beds), multiple = T, options = list( `actions-box` = TRUE, size = 10, `live-search` = TRUE )), pickerInput(inputId = &quot;rooms&quot;, label = &quot;Filtra por número de habitaciones&quot;, choices = levels(heatmapData$rooms), selected = levels(heatmapData$rooms), multiple = T, options = list( `actions-box` = TRUE, size = 10, `live-search` = TRUE )) ), dashboardBody( tags$head(tags$style(HTML(&#39; .skin-blue .main-header .logo { font-family: &quot;Nexa Bold&quot;; font-size: 24px; color: #000000; background-color: #eeaf30; } /* navbar (rest of the header) */ .skin-blue .main-header .navbar { background-color: #eeaf30; color: #000000; } &#39;))), fluidRow( h3(&quot;Selecciona en función de qué campo colorear el mapa de calor&quot;) ), fluidRow( pickerInput(inputId = &quot;color&quot;, choices = c(&quot;Número de Oportunidades&quot;, &quot;Número de Inmuebles&quot;, &quot;Número de Propuestas Aceptadas&quot;), selected = &quot;Número de Oportunidades&quot;, options = list( `actions-box` = TRUE, size = 10, `live-search` = TRUE )) ), fluidRow( leafletOutput(&quot;heatmap&quot;) %&gt;% withSpinner(color=&quot;#EEAF30&quot;) ), fluidRow( column(6, plotlyOutput(&quot;pricesLine&quot;) %&gt;% withSpinner(color=&quot;#EEAF30&quot;)), column(6, plotlyOutput(&quot;roomsBar&quot;) %&gt;% withSpinner(color=&quot;#EEAF30&quot;)) ), fluidRow( column(6, plotlyOutput(&quot;roomsPerDistrict&quot;) %&gt;% withSpinner(color=&quot;#EEAF30&quot;)), column(6, plotlyOutput(&quot;hasIcal&quot;) %&gt;% withSpinner(color=&quot;#EEAF30&quot;)) ), h3(&quot;Resumen por distrito&quot;), fluidRow( dataTableOutput(&quot;dataDistrito&quot;) %&gt;% withSpinner(color=&quot;#EEAF30&quot;) ) ) ) ) ##### ##### Desarrollo de los gráficos y de la reactividad (servidor) server &lt;- function(input, output, session) { result_auth &lt;- secure_server(check_credentials = check_credentials(credentials)) # observe({ # event &lt;- input$propertyCity # data &lt;- subset(polyData, propertyCity %in% event) # updateSelectInput(session = session, inputId = &quot;municipio&quot;, # selected = levels(data$municipio)) # }) # reactiveInputData &lt;- reactive({ # subset(polyData, propertyCity %in% input$propertyCity &amp; municipio %in% input$municipio &amp; distrito %in% input$distrito) # }) observe({ event &lt;- input$heatmap_shape_click updateSelectInput(session, inputId = &quot;distrito&quot;, selected = event$id) updateSelectInput(session, inputId = &quot;propertyCity&quot;, selected = levels(polyData$propertyCity)) updateSelectInput(session, inputId = &quot;municipio&quot;, selected = levels(polyData$municipio)) }) observe({ event &lt;- input$heatmap_marker_click updateSelectInput(session, inputId = &quot;distrito&quot;, selected = event$id) updateSelectInput(session, inputId = &quot;propertyCity&quot;, selected = levels(polyData$propertyCity)) updateSelectInput(session, inputId = &quot;municipio&quot;, selected = levels(polyData$municipio)) }) output$heatmap &lt;- renderLeaflet({ loadHeatmap(polyData, input$color) }) reactiveDistrictData &lt;- reactive({ heatmapData %&gt;% filter(propertyCity %in% input$propertyCity &amp; municipio %in% input$municipio &amp; distrito %in% input$distrito &amp; !is.na(monthlyPrice) &amp; beds %in% input$beds &amp; rooms %in% input$rooms) %&gt;% mutate(monthlyPrice = round(monthlyPrice, 0), duration = round(duration, 0)) }) reactivePropertiesData &lt;- reactive({ properties %&gt;% filter(distrito %in% input$distrito, !is.na(hasICal)) #%&gt;% # group_by(rooms) %&gt;% # summarise(numberOfProperties = n(), withIcal = sum(hasICal)) }) output$pricesLine &lt;- renderPlotly({ data &lt;- reactiveDistrictData() %&gt;% filter(!is.na(monthlyPrice) &amp; !is.na(rooms) &amp; rooms != &quot;nan&quot;) data$rooms &lt;- factor(data$rooms, levels = c(&quot;0.0&quot;, &quot;1.0&quot;, &quot;2.0&quot;, &quot;3.0&quot;, &quot;4.0&quot;, &quot;&gt;4&quot;), ordered = TRUE) p &lt;- ggplot(data = data, aes(y = monthlyPrice, group = rooms, color = rooms, text = toMoney(monthlyPrice))) + geom_boxplot() + scale_y_continuous(limits = c(0, 5000), breaks = seq(0, 5000, 500), name = &quot;Alquiler Mensual&quot;) + scale_x_discrete(name = &quot;Número de habitaciones&quot;) + labs(title = &quot;Alquiler de precios de alquiler en función del número de habitaciones&quot;, subtitle = &quot;Homyspace&quot;, fill = &quot;Número de habitaciones&quot;) + theme_minimal() ggplotly(p, tooltip = &quot;y&quot;) %&gt;% layout(boxmode=&#39;group&#39;, xaxis = list(autorange = T)) }) output$roomsBar &lt;- renderPlotly({ data &lt;- reactiveDistrictData() %&gt;% filter(!is.na(rooms) &amp; rooms != &quot;nan&quot;) p &lt;- ggplot(data = data, aes(x = rooms, fill = proposalStage)) + geom_bar() + scale_x_discrete(name = &quot;Número de habitaciones&quot;) + scale_y_continuous(name = &quot;Número de propuestas enviadas&quot;) + labs(title = &quot;Número de propuestas aceptadas y rechazadas por número de habitaciones&quot;, subtitle = &quot;Homyspace&quot;) + theme_minimal() ggplotly(p, tooltip = &quot;y&quot;) }) output$roomsPerDistrict &lt;- renderPlotly({ data &lt;- reactivePropertiesData() p &lt;- ggplot(data = data, aes(x=rooms, fill=rooms)) + geom_bar() + scale_x_discrete(name = &quot;Número de habitaciones&quot;) + scale_y_continuous(name = &quot;Número de inmuebles&quot;) + labs(title = &quot;Número de inmuebles por número de habitaciones&quot;, subtitle = &quot;Homyspace&quot;) + theme_minimal() ggplotly(p, tooltip = &quot;y&quot;) }) output$hasIcal &lt;- renderPlotly({ data &lt;- reactivePropertiesData() %&gt;% mutate(n=n()) %&gt;% group_by(hasICal) %&gt;% summarise(porcentaje = n()/mean(n)) p &lt;- ggplot(data = data, aes(x=hasICal, y=porcentaje, fill=hasICal)) + geom_bar(stat=&quot;identity&quot;) + scale_x_discrete(name = &quot;Tiene iCal&quot;) + scale_y_continuous(name = &quot;Porcentaje de inmuebles&quot;) + labs(title = &quot;Porcentaje de inmuebles con y sin iCal&quot;, subtitle = &quot;Homyspace&quot;) + theme_minimal() ggplotly(p, tooltip = &quot;y&quot;) }) output$dataDistrito &lt;- renderDataTable({ districtData &lt;- reactiveDistrictData() datatable(districtData %&gt;% group_by(distrito) %&gt;% summarise(numeroPropuestas = n(), numeroReservas = sum(proposalStage == &quot;ACCEPTED&quot;), benchmark = round(numeroReservas/numeroPropuestas, 2), precioMensual = round(median(monthlyPrice, na.rm = T), 2), duracionEstancia = median(duration, na.rm = T), inmuebles = length(unique(propertyId)), inmueblesConvertidos = n_distinct(propertyId[proposalStage == &quot;ACCEPTED&quot;]) ) %&gt;% arrange(desc(numeroPropuestas)), filter = &quot;top&quot;, selection=&quot;multiple&quot;, options = list( # autoWidth = TRUE, sDom = &#39;&lt;&quot;top&quot;&gt;lrt&lt;&quot;bottom&quot;&gt;ip&#39;, ordering = T, scrollX = T # lengthChange = FALSE, # info = FALSE, # paging = F ), rownames = F ) }) } ##### ##### Cargamos la aplicación con la interfaz de usuario (ui) y el servidor (server) shinyApp(ui = ui, server = server) "],
["referencias.html", "Referencias", " Referencias Boeing, Geoff. “Clustering to Reduce Spatial Data Set Size”. Clustering to Reduce Spatial Data Set Size. (2014). Bustillo, Rubén F. “¿Cómo realizar mapas de España con archivos shapefile?”. ¿Cómo realizar mapas de España con archivos shapefile?. (2019). Chambers, John M. et al. “Graphical Methods for Data Analysis”. (1983). Chang, Winston. “R Graphics Cookbook”. (2012). Correa, Juan Carlos y Nelfi González. “Grafícos Estadísticos con R”. (2002). Crane, Nic. “Interactive Maps in R with Shiny and Leaflet”. Interactive Maps in R with Shiny and Leaflet. (2016). Ellis, Laura. “Map Plots Created With R And Ggmap”. Map Plots Created With R And Ggmap. (2018). Engel, Claudia A. “Using Spatial Data with R”. Using Spatial Data with R. (2019). Friendly, Michael et al. The First (Known) Statistical Graph: Michael Florent van Langren and the “Secret” of Longitude. The First (Known) Statistical Graph: Michael Florent van Langren and the “Secret” of Longitude. (2010). Fry, Ben. “Visualizing Data”. (2008). Garrido, Manuel. “Making a Beautiful Map of Spain in ggplot2”. Making a Beautiful Map of Spain in ggplot2. (2017). Gregory, Matt. “Shiny interactive map app development”. Shiny interactive map app development.(2017). Holtz, Yan. “The R Graph Gallery”. The R Graph Gallery. Li, Angela. “R Spatial Workshop Notes”. R Spatial Workshop Notes. (2019). Maindonald, John and John Braun. “Data Analysis and Graphics Using R”. (2006). Milnes, Jason. “Effective Visualizations for Credible, Data-Driven Decision Making”. Effective Visualizations for Credible, Data-Driven Decision Making. (2020). Mittal, Hrishi V. “R Graphs Cookbook”. (2011). Molnar, Christoph. “Interpretable Machine Learning”. Interpretable Machine Learning. (2020) Moreno, Mel and Mathieu Basille. “Drawing beautiful maps programmatically with R, sf and ggplot2 - Part 1: Basics”. Drawing beautiful maps programmatically with R, sf and ggplot2 — Part 1: Basics. (2018). Pork Chop. Answer to “r - How to show Spinning Wheel or Busy Icon while waiting in Shiny”. r - How to show Spinning Wheel or Busy Icon while waiting in Shiny. (2018). r-tastic, “Exploring London Crime with R heat maps”. Exploring London Crime with R heat maps. (2018). shinyapps.io team. “Shinyapps.io user guide”. shinyapps.io user guide. (2020). Sievert, Carson. “Interactive web-based data visualization with R, plotly and shiny”. Interactive web-based data visualization with R, plotly, and shiny. (2019) Soltoff, Benjamin. “Computing for the Social Sciences”. Computing for the Social Sciences. (2020). Wickham, Hadley. “R for Data Science”. R for Data Science. (2017). Wyckoff, Joy P. “How to make interactive maps in R Shiny (brief tutorial)”. How to make interactive maps in R Shiny (brief tutorial). (2018). Xie, Yihui. “Bookdown: Authoring Books and Technical Documents with R Markdown”. Bookdown: Authoring Books and Technical Documents with R Markdown. (2020). Xie, Yihui et al. “R Markdown: The definitive Guide”. R Markdown: The definitive Guide. (2020) "]
]
